
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>web: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/elkcityhazard/andrew-mccall-go/cmd/web/init.go (0.0%)</option>
				
				<option value="file1">github.com/elkcityhazard/andrew-mccall-go/cmd/web/main.go (0.0%)</option>
				
				<option value="file2">github.com/elkcityhazard/andrew-mccall-go/cmd/web/middleware.go (0.0%)</option>
				
				<option value="file3">github.com/elkcityhazard/andrew-mccall-go/cmd/web/parseflags.go (0.0%)</option>
				
				<option value="file4">github.com/elkcityhazard/andrew-mccall-go/cmd/web/routes.go (0.0%)</option>
				
				<option value="file5">github.com/elkcityhazard/andrew-mccall-go/cmd/web/session.go (0.0%)</option>
				
				<option value="file6">github.com/elkcityhazard/andrew-mccall-go/internal/database/database.go (0.0%)</option>
				
				<option value="file7">github.com/elkcityhazard/andrew-mccall-go/internal/forms/errors.go (0.0%)</option>
				
				<option value="file8">github.com/elkcityhazard/andrew-mccall-go/internal/forms/forms.go (0.0%)</option>
				
				<option value="file9">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_delete_post.go (0.0%)</option>
				
				<option value="file10">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_generate_slug.go (0.0%)</option>
				
				<option value="file11">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_admin.go (0.0%)</option>
				
				<option value="file12">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_admin_categories.go (0.0%)</option>
				
				<option value="file13">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_admin_resume.go (0.0%)</option>
				
				<option value="file14">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_blog.go (0.0%)</option>
				
				<option value="file15">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_compose.go (0.0%)</option>
				
				<option value="file16">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_contact.go (0.0%)</option>
				
				<option value="file17">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_edit_compose.go (0.0%)</option>
				
				<option value="file18">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_post.go (0.0%)</option>
				
				<option value="file19">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_resume.go (0.0%)</option>
				
				<option value="file20">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_signup_success.go (0.0%)</option>
				
				<option value="file21">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_success.go (0.0%)</option>
				
				<option value="file22">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_get_user_activation.go (0.0%)</option>
				
				<option value="file23">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_post_admin_resume.go (0.0%)</option>
				
				<option value="file24">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_post_category.go (0.0%)</option>
				
				<option value="file25">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_post_compose.go (0.0%)</option>
				
				<option value="file26">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_post_contact.go (0.0%)</option>
				
				<option value="file27">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_post_upload_image.go (0.0%)</option>
				
				<option value="file28">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_post_user_activation.go (0.0%)</option>
				
				<option value="file29">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handle_put_compose.go (0.0%)</option>
				
				<option value="file30">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handlers.go (0.0%)</option>
				
				<option value="file31">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/handlestatic.go (0.0%)</option>
				
				<option value="file32">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/hane_post_signup.go (0.0%)</option>
				
				<option value="file33">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/login_get_handler.go (0.0%)</option>
				
				<option value="file34">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/login_post_handler.go (0.0%)</option>
				
				<option value="file35">github.com/elkcityhazard/andrew-mccall-go/internal/handlers/signup_get_handler.go (0.0%)</option>
				
				<option value="file36">github.com/elkcityhazard/andrew-mccall-go/internal/mailer/mailer.go (0.0%)</option>
				
				<option value="file37">github.com/elkcityhazard/andrew-mccall-go/internal/models/category.go (0.0%)</option>
				
				<option value="file38">github.com/elkcityhazard/andrew-mccall-go/internal/models/ops.go (0.0%)</option>
				
				<option value="file39">github.com/elkcityhazard/andrew-mccall-go/internal/models/resume.go (0.0%)</option>
				
				<option value="file40">github.com/elkcityhazard/andrew-mccall-go/internal/models/templatedata.go (0.0%)</option>
				
				<option value="file41">github.com/elkcityhazard/andrew-mccall-go/internal/models/user.go (0.0%)</option>
				
				<option value="file42">github.com/elkcityhazard/andrew-mccall-go/internal/render/render.go (0.0%)</option>
				
				<option value="file43">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/delete_post_by_id.go (0.0%)</option>
				
				<option value="file44">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_award_list.go (0.0%)</option>
				
				<option value="file45">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_category_by_post_id.go (0.0%)</option>
				
				<option value="file46">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_education_list.go (0.0%)</option>
				
				<option value="file47">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_employment_list.go (0.0%)</option>
				
				<option value="file48">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_reference_list.go (0.0%)</option>
				
				<option value="file49">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_resume_by_id.go (0.0%)</option>
				
				<option value="file50">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_resume_contact_details.go (0.0%)</option>
				
				<option value="file51">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_resume_objective.go (0.0%)</option>
				
				<option value="file52">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_resume_skill_list.go (0.0%)</option>
				
				<option value="file53">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/get_resume_social_media_list.go (0.0%)</option>
				
				<option value="file54">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/insert_category.go (0.0%)</option>
				
				<option value="file55">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/insert_category_post_join.go (0.0%)</option>
				
				<option value="file56">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/insert_message.go (0.0%)</option>
				
				<option value="file57">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/insert_resume.go (0.0%)</option>
				
				<option value="file58">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/list_categories.go (0.0%)</option>
				
				<option value="file59">github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn/sqldbconn.go (0.0%)</option>
				
				<option value="file60">github.com/elkcityhazard/andrew-mccall-go/internal/static/static.go (0.0%)</option>
				
				<option value="file61">github.com/elkcityhazard/andrew-mccall-go/internal/templates/template.go (0.0%)</option>
				
				<option value="file62">github.com/elkcityhazard/andrew-mccall-go/pkg/utils/slugify.go (94.4%)</option>
				
				<option value="file63">github.com/elkcityhazard/andrew-mccall-go/pkg/utils/utils.go (60.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "net/http"
        "os"
        "sync"
        "time"

        "github.com/alexedwards/argon2id"
        "github.com/elkcityhazard/andrew-mccall-go/internal/config"
        "github.com/elkcityhazard/andrew-mccall-go/internal/database"
        "github.com/elkcityhazard/andrew-mccall-go/internal/handlers"
        "github.com/elkcityhazard/andrew-mccall-go/internal/mailer"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
        "github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn"
        "github.com/elkcityhazard/andrew-mccall-go/internal/templates"
)

const (
        TIMEOUT_DURATION    = time.Second * 30
        CONN_MAX_LIFETIME   = time.Minute * 3
        CONN_MAX_OPEN_CONNS = 10
        CONN_MAX_IDLE_CONNS = 30
        CONN_MAX_IDLE_TIME  = time.Second * 90
)

// msgListern listens for any message and prints it to the console
func msgListener(msgChan chan string) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case msg := &lt;-msgChan:<span class="cov0" title="0">
                        log.Println(msg)</span>
                }
        }
}

// run starts the application
func run() <span class="cov0" title="0">{
        email := os.Getenv("USER_EMAIL")
        password := os.Getenv("USER_PASSWORD")
        app.MsgChan = make(chan string)
        app.TemplateCache = templates.BuildTemplateCache()
        app.WG = &amp;sync.WaitGroup{}
        app.MU = &amp;sync.Mutex{}
        app.Context = context.Background()

        // dummy mailer setup
        mailDispatcher := mailer.New("localhost", 1025, "username", "password", "web@andrew-mccall.com")
        app.Mailer = mailDispatcher
        go mailDispatcher.ListenForIncomingEmail()
        flagChan := make(chan bool)
        go msgListener(app.MsgChan)
        go parseFlags(&amp;app, flagChan)
        &lt;-flagChan
        db, err := connectToDB(&amp;app)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov0" title="0">defer db.Close()
        newSessionManager(&amp;app, db)
        render.NewRenderer(&amp;app)
        dbServicer := sqldbconn.NewSQLDbConn(&amp;app, db)
        handlerRepo := handlers.NewHandlerRepo(&amp;app, dbServicer)
        handlers.SetHandlerRepo(handlerRepo)

        // pass the handler repo into the templates so we can fetch the author without some extra one off model for an inner join
        templates.SetTemplateSQLDbRepo(dbServicer)

        superAdmin := createSeedUser(email, password)

        _, err = dbServicer.InsertUser(superAdmin)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov0" title="0">startServer(&amp;app)</span>
}

func createSeedUser(email, password string) *models.User <span class="cov0" title="0">{

        p := models.Password{}

        p.PlainText = password

        pwHash, err := argon2id.CreateHash(p.PlainText, argon2id.DefaultParams)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov0" title="0">p.Hash = pwHash

        u := &amp;models.User{
                Email:    email,
                Username: "elkcityhazard",
                Password: &amp;p,
                Role:     "super_admin",
                IsActive: true,
        }

        return u</span>

}

// startServer starts the server on the specified port
func startServer(app *config.AppConfig) <span class="cov0" title="0">{

        fmt.Printf("Starting server on: %s\n", app.Port)

        srv := &amp;http.Server{
                Addr:              app.Port,
                Handler:           LoadSession(csrfToken(stripTrailingSlash(routes()))),
                IdleTimeout:       TIMEOUT_DURATION,
                WriteTimeout:      TIMEOUT_DURATION,
                ReadTimeout:       TIMEOUT_DURATION,
                ReadHeaderTimeout: TIMEOUT_DURATION,
                MaxHeaderBytes:    2 &gt;&gt; 30,
        }

        if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>
}

// connectToDB watis for initDB to get done and returns the database conn and an error
func connectToDB(app *config.AppConfig) (*sql.DB, error) <span class="cov0" title="0">{
        db := make(chan *sql.DB)
        err := make(chan error)
        done := make(chan bool)
        go initDB(app, db, err, done)
        for </span><span class="cov0" title="0">{
                select </span>{
                case d := &lt;-db:<span class="cov0" title="0">
                        return d, nil</span>
                case e := &lt;-err:<span class="cov0" title="0">
                        return nil, e</span>
                case &lt;-done:<span class="cov0" title="0">
                        close(db)
                        close(err)
                        close(done)</span>
                }
        }
}

// initDB initializes a new database connection and sends it to the receiver channel
func initDB(app *config.AppConfig, dbChan chan&lt;- *sql.DB, dbErrorChan chan&lt;- error, dbDoneChan chan&lt;- bool) <span class="cov0" title="0">{
        db, err := database.NewDriver(app)
        if err != nil </span><span class="cov0" title="0">{
                dbErrorChan &lt;- err
                dbDoneChan &lt;- true
        }</span>
        <span class="cov0" title="0">if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                dbErrorChan &lt;- err
                dbDoneChan &lt;- true
        }</span>
        <span class="cov0" title="0">db.SetConnMaxLifetime(CONN_MAX_LIFETIME)
        db.SetMaxOpenConns(CONN_MAX_OPEN_CONNS)
        db.SetMaxIdleConns(CONN_MAX_IDLE_CONNS)
        db.SetConnMaxIdleTime(CONN_MAX_IDLE_TIME)
        dbChan &lt;- db
        dbDoneChan &lt;- true</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/elkcityhazard/andrew-mccall-go/internal/config"
)

var app = config.AppConfig{}

func main() <span class="cov0" title="0">{
        run()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "net/http"
        "strings"

        "github.com/justinas/nosurf"
)

func LoadSession(next http.Handler) http.Handler <span class="cov0" title="0">{
        return app.SessionManager.LoadAndSave(next)
}</span>

func returnsJSON(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                next.ServeHTTP(w, r.WithContext(r.Context()))
        }</span>)
}

func requiresAuth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                isValidSession := app.SessionManager.Exists(r.Context(), "id")
                if !isValidSession </span><span class="cov0" title="0">{
                        http.Redirect(w, r.WithContext(r.Context()), "/login", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r.WithContext(r.Context()))</span>
        })

}

func csrfToken(next http.Handler) http.Handler <span class="cov0" title="0">{
        csrfHandler := nosurf.New(next)

        csrfHandler.SetBaseCookie(http.Cookie{
                HttpOnly: true,
                Path:     "/",
                Secure:   app.IsProduction,
                SameSite: http.SameSiteLaxMode,
        })

        return csrfHandler
}</span>

func stripTrailingSlash(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                p := r.URL.Path
                switch true </span>{
                case p == "/" &amp;&amp; len(p) &lt; 2:<span class="cov0" title="0">
                        next.ServeHTTP(w, r.WithContext(r.Context()))</span>
                // handle dir browsing
                case strings.HasPrefix(p, "/static/"):<span class="cov0" title="0">
                        if p[len(p)-1:] == "/" </span><span class="cov0" title="0">{
                                http.NotFound(w, r)
                                return
                        }</span>
                        <span class="cov0" title="0">next.ServeHTTP(w, r.WithContext(r.Context()))</span>
                case p[len(p)-1:] == "/":<span class="cov0" title="0">
                        http.Redirect(w, r.WithContext(r.Context()), p[:len(p)-1], http.StatusSeeOther)</span>
                default:<span class="cov0" title="0">
                        next.ServeHTTP(w, r.WithContext(r.Context()))</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "flag"
        "fmt"

        "github.com/elkcityhazard/andrew-mccall-go/internal/config"
)

func parseFlags(app *config.AppConfig, boolChan chan&lt;- bool) <span class="cov0" title="0">{

        flag.StringVar(&amp;app.SiteTitle, "site_title", "Andrew M McCall - Bits &amp; Bytes", "Pass in your site title here")
        flag.StringVar(&amp;app.Port, "site_port", ":8080", "This is the port the application runs on")
        flag.StringVar(&amp;app.DSN, "DSN", "", "The database connection string")
        flag.BoolVar(&amp;app.IsProduction, "is_production", false, "is the app in production? (true|false)")

        flag.Parse()

        fmt.Println(app.SiteTitle)

        boolChan &lt;- true

}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "errors"
        "net/http"
        "regexp"
        "strings"

        "github.com/elkcityhazard/andrew-mccall-go/internal/handlers"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
        "github.com/elkcityhazard/andrew-mccall-go/internal/static"
)

type router struct {
        routes []*route
}

func (m *router) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        // Handle static files first
        if strings.HasPrefix(r.URL.Path, "/static/") </span><span class="cov0" title="0">{
                // if not in prod, load static resources from disk, else embed
                if !app.IsProduction </span><span class="cov0" title="0">{
                        fileServer := http.FileServer(http.Dir("./internal/static/"))
                        http.StripPrefix("/static/", fileServer).ServeHTTP(w, r)

                }</span> else<span class="cov0" title="0"> {
                        fileServer := http.FileServer(http.FS(static.GetStaticDir()))
                        http.StripPrefix("/static/", fileServer).ServeHTTP(w, r)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if strings.HasPrefix(r.URL.Path, "/uploads/") </span><span class="cov0" title="0">{
                fileServer := http.FileServer(http.Dir("./uploads/"))
                http.StripPrefix("/uploads/", fileServer).ServeHTTP(w, r)

                return
        }</span>

        <span class="cov0" title="0">var allow []string

        for _, v := range m.routes </span><span class="cov0" title="0">{
                matches := v.regex.FindStringSubmatch(r.URL.Path)
                if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                        if r.Method != v.method </span><span class="cov0" title="0">{
                                allow = append(allow, v.method)
                                continue</span>
                        }

                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), handlers.CtxKey{}, matches[1:])

                        // handle middleware
                        // last in first out algo

                        if len(v.middleware) &gt; 0 </span><span class="cov0" title="0">{
                                for i := len(v.middleware) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                        // pass handler into middleware and update handler with new middleware
                                        v.handler = v.middleware[i](v.handler).ServeHTTP
                                }</span>
                        }

                        <span class="cov0" title="0">v.handler(w, r.WithContext(ctx))
                        return</span>
                }
        }
        <span class="cov0" title="0">if len(allow) &gt; 0 </span><span class="cov0" title="0">{
                w.Header().Set("Allow", strings.Join(allow, ", "))
                w.WriteHeader(405)
                err := errors.New("405 method not allowed")
                http.Error(w, err.Error(), http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(404)
        render.RenderTemplate(w, r, "404.gohtml", &amp;models.TemplateData{})
        return</span>

}

// New accepts a method, pattern, http.HandlerFunc, and an array of middlewares and adds it to the list of allowed routes
func (m *router) New(method, pattern string, handler http.HandlerFunc, mware ...func(next http.Handler) http.Handler) <span class="cov0" title="0">{
        m.routes = append(m.routes, &amp;route{
                method:     method,
                regex:      regexp.MustCompile("^" + pattern + "$"),
                handler:    handler,
                middleware: mware,
        })
}</span>

type route struct {
        method     string
        regex      *regexp.Regexp
        handler    http.HandlerFunc
        middleware []func(http.Handler) http.Handler
}

func routes() http.Handler <span class="cov0" title="0">{

        rtr := &amp;router{}

        rtr.New("GET", "/", handlers.Repo.HomeGetHandler)
        rtr.New("GET", "/success", handlers.Repo.HandleGetSuccess)

        rtr.New("GET", "/signup", handlers.Repo.SignupGetHandler)
        rtr.New("POST", "/signup", handlers.Repo.HandlePostSignup)
        rtr.New("GET", "/signup/success", handlers.Repo.HandleGetSignupSuccess)

        rtr.New("GET", "/login", handlers.Repo.LoginGetHandler)
        rtr.New("POST", "/login", handlers.Repo.LoginPostHandler)

        rtr.New("GET", "/admin", handlers.Repo.HandleGetAdmin, requiresAuth)
        rtr.New("GET", "/admin/compose", handlers.Repo.HandleGetCompose, requiresAuth)
        rtr.New("POST", "/admin/compose", handlers.Repo.HandlePostCompose, requiresAuth)
        rtr.New("POST", "/admin/delete", handlers.Repo.HandleDeletePost, requiresAuth)

        rtr.New("GET", "/admin/compose/edit/([0-9]+)", handlers.Repo.HandleGetEditCompose, requiresAuth)
        rtr.New("PUT", "/admin/compose/edit/([0-9]+)", handlers.Repo.HandlePutCompose, requiresAuth, returnsJSON)

        // resume crud
        rtr.New("GET", "/admin/resume", handlers.Repo.HandleGetAdminResume, requiresAuth)
        rtr.New("POST", "/admin/resume", handlers.Repo.HandlePostAdminResume, requiresAuth)

        // Admin Manage Categories
        rtr.New("GET", "/admin/categories", handlers.Repo.HandleGetAdminCategories, requiresAuth)

        rtr.New("GET", "/blog", handlers.Repo.HandleGetBlog)
        rtr.New("GET", `/blog/([\w-\/]+)`, handlers.Repo.HandleGetPost)
        rtr.New("GET", `/resume`, handlers.Repo.HandleGetResume)

        // handle activation
        rtr.New("GET", "/users/activation", handlers.Repo.HandleGetUserActivation)
        rtr.New("POST", "/users/activation", handlers.Repo.HandlePostUserActivation)

        // Contact
        rtr.New("GET", "/contact", handlers.Repo.HandleGetContact)
        rtr.New("POST", "/contact", handlers.Repo.HandlePostContact)

        //API routes

        rtr.New("POST", "/api/v1/upload/image", handlers.Repo.HandlePostUploadImage, requiresAuth, returnsJSON)
        rtr.New("POST", "/api/v1/category", handlers.Repo.HandlePostCategory, requiresAuth, returnsJSON)
        rtr.New("POST", "/api/v1/generate-slug", handlers.Repo.HandleGenerateSlug, requiresAuth, returnsJSON)

        return rtr

}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "database/sql"

        "github.com/alexedwards/scs/mysqlstore"
        "github.com/alexedwards/scs/v2"
        "github.com/elkcityhazard/andrew-mccall-go/internal/config"
)

func newSessionManager(app *config.AppConfig, db *sql.DB) <span class="cov0" title="0">{
        session := scs.New()
        session.Store = mysqlstore.New(db)
        app.SessionManager = session

}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "database/sql"

        "github.com/elkcityhazard/andrew-mccall-go/internal/config"
        _ "github.com/go-sql-driver/mysql"
)

func NewDriver(app *config.AppConfig) (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("mysql", app.DSN)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package forms

type errors map[string][]string

// Add adds an error message for a given form field.
func (e errors) Add(field, message string) <span class="cov0" title="0">{
        e[field] = append(e[field], message)
}</span>

// Get returns the first error message.
func (e errors) Get(field string) string <span class="cov0" title="0">{
        es := e[field]
        if len(es) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return es[0]</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package forms

import (
        "fmt"
        "net/mail"
        "net/url"
        "strings"
)

// Form creates a custom form struct, embeds a url.Values object
type Form struct {
        url.Values
        Errors errors
}

// Valid returns true if there are no errors, otherwise false
func (f *Form) Valid() bool <span class="cov0" title="0">{
        return len(f.Errors) == 0
}</span>

// New initializes a form struct
func New(data url.Values) *Form <span class="cov0" title="0">{
        return &amp;Form{
                data,
                errors(map[string][]string{}),
        }
}</span>

// Required checks for required fields
func (f *Form) Required(fields ...string) <span class="cov0" title="0">{
        for _, field := range fields </span><span class="cov0" title="0">{
                value := f.Get(field)
                if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                        f.Errors.Add(field, "This field cannot be blank")
                }</span>
        }
}

// Has checks if form field is in post and not empty
func (f *Form) Has(field string) bool <span class="cov0" title="0">{
        x := f.Get(field)
        if x == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// MinLength checks for string minimum length
func (f *Form) MinLength(field string, length int) bool <span class="cov0" title="0">{
        x := f.Get(field)
        if len(x) &lt; length </span><span class="cov0" title="0">{
                f.Errors.Add(field, fmt.Sprintf("This field must be at least %d characters long", length))
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// IsEmail checks for valid email address
func (f *Form) IsEmail(field string) bool <span class="cov0" title="0">{
        _, err := mail.ParseAddress(field)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "net/http"
        "strconv"
)

func (hr *HandlerRepo) HandleDeletePost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := hr.app.SessionManager.GetInt64(r.Context(), "id")

        if userID == 0 </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/login", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">id, err := strconv.ParseInt(r.URL.Query().Get("id"), 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/admin", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">if id == 0 </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/admin", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">res, err := hr.conn.DeletePostById(id, userID)

        stringMap := make(map[string]string)

        stringMap["PageTitle"] = "Admin"

        if err != nil </span><span class="cov0" title="0">{
                hr.app.SessionManager.Put(r.Context(), "error", err.Error())
                http.Redirect(w, r.WithContext(r.Context()), "/admin", http.StatusSeeOther)
                return

        }</span>

        <span class="cov0" title="0">if res &gt; 0 </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/admin", http.StatusSeeOther)
                return

        }</span>

        <span class="cov0" title="0">http.NotFound(w, r)</span>

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "fmt"
        "html"
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/pkg/utils"
        "github.com/justinas/nosurf"
)

func (hr *HandlerRepo) HandleGenerateSlug(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if !nosurf.VerifyToken(r.Header.Get("X-CSRF-Token"), nosurf.Token(r)) </span><span class="cov0" title="0">{
                returnErr(w, errors.New("unauthorized"))
                return
        }</span>

        <span class="cov0" title="0">u := utils.NewUtil()

        type slug struct {
                Value string `json:"value"`
        }

        var incoming slug

        err := json.NewDecoder(r.Body).Decode(&amp;incoming)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">outgoing := u.Slugify(html.EscapeString(incoming.Value))

        type Payload struct {
                Status int    `json:"status"`
                Slug   string `json:"slug"`
        }

        p := Payload{
                Status: http.StatusOK,
                Slug:   fmt.Sprintf("%s", outgoing),
        }

        err = json.NewEncoder(w).Encode(p)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "log"
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetAdmin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if !hr.app.SessionManager.Exists(r.Context(), "id") </span><span class="cov0" title="0">{
                http.Redirect(w, r.WithContext(r.Context()), "/login", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">userID := hr.app.SessionManager.GetInt64(r.Context(), "id")

        posts, err := hr.conn.GetPaginatedPosts(userID, 0, 20)

        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov0" title="0">data := make(map[string]any)

        data["Posts"] = posts

        stringMap := make(map[string]string)

        stringMap["PageTitle"] = "Admin Home"
        render.RenderTemplate(w, r, "admin-home.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Data:      data,
                Form:      forms.New(nil),
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetAdminCategories(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        cats, err := hr.conn.ListCategories()

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">stringMap := make(map[string]string)

        stringMap["PageTitle"] = "Categories - Admin"

        data := make(map[string]any)
        data["Categories"] = cats

        render.RenderTemplate(w, r, "admin-categories.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Data:      data,
                Form:      forms.New(nil),
        })</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetAdminResume(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        data, stringMap, intMap, form := hr.CreateEmptyTemplatePayload()

        stringMap["PageTitle"] = "Resume"
        data["UserID"] = hr.app.SessionManager.GetInt64(r.Context(), "id")
        render.RenderTemplate(w, r, "admin-resume.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Data:      data,
                IntMap:    intMap,
                Form:      form,
        })
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "strconv"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetBlog(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        limitParam, err := strconv.Atoi(r.URL.Query().Get("limit"))
        if err != nil </span><span class="cov0" title="0">{
                limitParam = 10
        }</span>
        <span class="cov0" title="0">offsetParam, err := strconv.Atoi(r.URL.Query().Get("offset"))
        if err != nil </span><span class="cov0" title="0">{
                offsetParam = 0
        }</span>

        <span class="cov0" title="0">posts, err := hr.conn.ListPosts(limitParam, offsetParam)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">count, err := hr.conn.GetTotalCount("posts")

        if err != nil </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                returnErr(w, err)
                return
        }</span>
        <span class="cov0" title="0">intMap := make(map[string]int)

        intMap["Limit"] = limitParam
        intMap["Count"] = count
        intMap["Offset"] = offsetParam

        data := make(map[string]interface{})
        data["Posts"] = posts
        data["Count"] = count

        stringMap := make(map[string]string)

        stringMap["PageTitle"] = "Blog"

        if len(posts) &lt; 1 </span><span class="cov0" title="0">{

                if offsetParam-limitParam &lt; 0 </span><span class="cov0" title="0">{
                        http.Redirect(w, r.WithContext(r.Context()), fmt.Sprintf("/blog?limit=%d&amp;offset=%d", limitParam, 0), http.StatusSeeOther)
                }</span> else<span class="cov0" title="0"> {
                        http.Redirect(w, r.WithContext(r.Context()), fmt.Sprintf("/blog?limit=%d&amp;offset=%d", limitParam, offsetParam-limitParam), http.StatusSeeOther)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">render.RenderTemplate(w, r, "blog.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                IntMap:    intMap,
                Data:      data,
                Form:      forms.New(nil),
        })</span>

}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetCompose(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var stringMap = map[string]string{}
        stringMap["PageTitle"] = "Compose"

        data := make(map[string]any)

        cats, err := hr.conn.ListCategories()

        if err != nil </span><span class="cov0" title="0">{
                hr.app.SessionManager.Put(r.Context(), "error", "there was an error fetching the categories")
        }</span>

        <span class="cov0" title="0">data["Categories"] = cats

        render.RenderTemplate(w, r, "compose.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Data:      data,
                Form:      forms.New(nil),
        })</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetContact(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        stringMap := make(map[string]string)

        stringMap["PageTitle"] = "Contact"
        render.RenderTemplate(w, r, "contact.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Form:      forms.New(nil),
        })
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "net/url"
        "strconv"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetEditCompose(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        paramKey, err := strconv.ParseInt(GetField(r, 0), 10, 32)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">post, err := hr.conn.GetBlogPostByID(paramKey)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">var f = forms.New(url.Values{})

        f.Set("title", post.Title)
        f.Set("slug", post.Slug)
        f.Set("description", post.Description)
        f.Set("content", post.Content)
        stringMap := make(map[string]string)

        stringMap["Title"] = fmt.Sprintf("Edit: %s", post.Title)
        stringMap["Method"] = "PUT"
        stringMap["Action"] = fmt.Sprintf("/admin/compose/edit/%d", post.ID)

        var data = map[string]interface{}{}

        category, err := hr.conn.GetCategoryByPostID(post.ID)

        if err != nil </span><span class="cov0" title="0">{
                category = models.NewCategory()
        }</span>

        <span class="cov0" title="0">f.Set("category", category.Name)

        categories, err := hr.conn.ListCategories()

        if err != nil </span><span class="cov0" title="0">{
                categories = nil
        }</span>

        <span class="cov0" title="0">data["Post"] = post
        data["PostCategory"] = category
        data["Categories"] = categories
        data["EditorContent"] = post.Delta

        var intMap = map[string]int{}

        intMap["PostID"] = int(post.ID)

        fmt.Printf("%+v\n\n", data)

        render.RenderTemplate(w, r, "compose.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                IntMap:    intMap,
                Data:      data,
                Form:      f,
        })</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetPost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        // since this route starts with /blog we can extract the route key pretty easily to fetch by sluga

        routeKey := r.URL.Path[len("/blog"):]

        post, err := hr.conn.GetBlogPost(routeKey)

        if err != nil </span><span class="cov0" title="0">{
                hr.app.MsgChan &lt;- err.Error()
                render.RenderTemplate(w, r, "404.gohtml", &amp;models.TemplateData{})
                return
        }</span>

        <span class="cov0" title="0">cat, err := hr.conn.GetCategoryByPostID(post.ID)

        if err != nil </span><span class="cov0" title="0">{
                cat = &amp;models.Category{}
        }</span>

        <span class="cov0" title="0">prevPost, err := hr.conn.GetNextPrevPost(post, false)

        if err != nil </span><span class="cov0" title="0">{
                prevPost = &amp;models.Content{}
        }</span>

        <span class="cov0" title="0">nextPost, err := hr.conn.GetNextPrevPost(post, true)

        if err != nil </span><span class="cov0" title="0">{
                nextPost = &amp;models.Content{}

        }</span>

        <span class="cov0" title="0">var stringMap = map[string]string{}

        stringMap["PageTitle"] = post.Title
        stringMap["PageDescription"] = post.Description

        var data = map[string]interface{}{}
        data["Post"] = post
        data["Category"] = cat
        data["PrevPost"] = prevPost
        data["NextPost"] = nextPost

        render.RenderTemplate(w, r, "single-post.gohtml", &amp;models.TemplateData{
                Data:      data,
                StringMap: stringMap,
        })</span>

}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetResume(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        userID := hr.app.SessionManager.GetInt64(r.Context(), "id")

        if userID == 0 </span><span class="cov0" title="0">{
                userID = 1
        }</span>

        <span class="cov0" title="0">resume, err := hr.conn.GetResumeById(userID)

        if err != nil </span><span class="cov0" title="0">{
                render.RenderTemplate(w, r, "404.gohtml", &amp;models.TemplateData{})
                return
        }</span>

        <span class="cov0" title="0">objective, err := hr.conn.GetResumeObjective(resume.ID)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">resume.Objective = objective

        contactDetails, err := hr.conn.GetResumeContactDetails(resume.ID)

        if err != nil </span><span class="cov0" title="0">{
                contactDetails = models.NewContactDetail()
        }</span>

        <span class="cov0" title="0">resume.ContactDetail = contactDetails

        socialList, err := hr.conn.GetResumeSocialMedia(resume.ID)

        if err != nil </span><span class="cov0" title="0">{
                socialList = models.NewSocialMediaList()
                return
        }</span>
        <span class="cov0" title="0">resume.SocialMediaList = socialList

        awardList, err := hr.conn.GetAwardItems(resume.ID)

        if err != nil </span><span class="cov0" title="0">{
                awardList = models.NewAwardsList()
        }</span>
        <span class="cov0" title="0">resume.AwardsList = awardList

        skillList, err := hr.conn.GetSkillItems(resume.ID)

        if err != nil </span><span class="cov0" title="0">{
                skillList = models.NewSkillList()
        }</span>

        <span class="cov0" title="0">resume.SkillList = skillList

        employmentList, err := hr.conn.GetEmploymentList(resume.ID)

        if err != nil </span><span class="cov0" title="0">{
                employmentList = models.NewEmploymentList()
        }</span>

        <span class="cov0" title="0">resume.EmploymentList = employmentList

        educationList, err := hr.conn.GetEducationList(resume.ID)

        if err != nil </span><span class="cov0" title="0">{
                educationList = models.NewEducationList()
        }</span>

        <span class="cov0" title="0">resume.EducationList = educationList

        refList, err := hr.conn.GetReferenceList(resume.ID)

        if err != nil </span><span class="cov0" title="0">{
                refList = models.NewReferenceList()
        }</span>

        <span class="cov0" title="0">resume.ReferenceList = refList

        data := make(map[string]any)
        stringMap := make(map[string]string)

        data["Resume"] = resume

        stringMap["PageTitle"] = "Resume"

        render.RenderTemplate(w, r, "resume.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Data:      data,
                Form:      nil,
        })</span>

}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetSignupSuccess(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        id := hr.app.SessionManager.GetInt64(r.Context(), "id")

        if id == 0 </span><span class="cov0" title="0">{
                err := errors.New("invalid request")
                returnErr(w, err)
                return
        }</span>
        <span class="cov0" title="0">user, err := hr.conn.GetUserByID(id)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">stringMap := make(map[string]string)

        stringMap["PageTitle"] = fmt.Sprintf("%s - success", user.Email)

        data := make(map[string]any)
        data["User"] = user

        render.RenderTemplate(w, r, "success.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Data:      data,
        })</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetSuccess(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        stringMap := make(map[string]string)
        stringMap["PageTitle"] = "Success"

        render.RenderTemplate(w, r, "default-success.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
        })

}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package handlers

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandleGetUserActivation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        token := r.URL.Query().Get("token")
        id := r.URL.Query().Get("id")

        if token == "" || id == "" </span><span class="cov0" title="0">{
                err := errors.New("there has been an error")
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">user, actTok, err := hr.conn.GetActivationToken(token)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">stringMap := make(map[string]string)
        stringMap["PageTitle"] = fmt.Sprintf("Welcome, %s!", user.Email)

        data := make(map[string]any)

        data["User"] = user
        data["ActivationToken"] = actTok

        render.RenderTemplate(w, r, "get-user-activation.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Data:      data,
        })</span>

}
</pre>
		
		<pre class="file" id="file23" style="display: none">package handlers

import (
        "encoding/json"
        "html"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandlePostAdminResume(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        err := r.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>
        <span class="cov0" title="0">resumeForm := forms.New(r.Form)

        // required fields

        resumeForm.Required(
                "resume_job_title",
                "resume_contact-details_firstname",
                "resume_contact-details_lastname",
                "resume_contact-details_address1",
                "resume_contact-details_city",
                "resume_contact-details_state",
                "resume_contact-details_zipcode",
                "resume_contact-details_email",
                "resume_contact-details_phone",
        )

        var employmentListKeys []string

        var elPrefix = "resume_employment-list_"
        employmentListKeys = append(employmentListKeys, elPrefix+"title", elPrefix+"from_date", elPrefix+"to_date", elPrefix+"job_title", elPrefix+"summary")

        for i := 0; i &lt; len(employmentListKeys); i++ </span><span class="cov0" title="0">{
                var key = employmentListKeys[i]
                if len(key) &gt; 0 </span><span class="cov0" title="0">{
                        resumeForm.Required(employmentListKeys...)
                }</span>
        }

        <span class="cov0" title="0">if !resumeForm.IsEmail(resumeForm.Get("resume_contact-details_email")) </span><span class="cov0" title="0">{
                resumeForm.Errors.Add("resume_contact-details_email", "invalid email address")
        }</span>

        <span class="cov0" title="0">if !resumeForm.Valid() </span><span class="cov0" title="0">{
                data, stringMap, intMap, _ := hr.CreateEmptyTemplatePayload()

                stringMap["PageTitle"] = "Resume"
                data["UserID"] = hr.app.SessionManager.GetInt64(r.Context(), "id")
                render.RenderTemplate(w, r, "admin-resume.gohtml", &amp;models.TemplateData{
                        StringMap: stringMap,
                        Data:      data,
                        IntMap:    intMap,
                        Form:      resumeForm,
                })
                return
        }</span>

        // New resume
        <span class="cov0" title="0">var res = models.NewResume()
        res.UserID = hr.app.SessionManager.GetInt64(r.Context(), "id")
        res.JobTitle = html.EscapeString(resumeForm.Get("resume_job_title"))

        // contact details
        res.ContactDetail = parseFormIntoContactDetails(&amp;resumeForm.Values)

        // Objective

        var resObjective = models.NewObjective()
        resObjective.Content = html.EscapeString(resumeForm.Get("resume_objective"))
        res.Objective = resObjective

        res.SocialMediaList = parseSocialList(resumeForm)

        res.SkillList = parseFormIntoSkillList(resumeForm)

        res.AwardsList = parseAwardsList(resumeForm)

        res.EmploymentList = parseEmploymentList(resumeForm)

        res.EducationList = parseEducationList(resumeForm)

        res.ReferenceList = parseReferenceList(resumeForm)

        resumeID, err := hr.conn.InsertResume(res)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">res.ID = resumeID

        w.Header().Set("Content-Type", "application/json")

        err = json.NewEncoder(w).Encode(res)</span>

}

func escapeHTML(s string) string <span class="cov0" title="0">{

        if len(s) &lt; 1 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">s = strings.TrimSpace(s)
        return html.EscapeString(s)</span>
}

func parseStringToInt(s string) int <span class="cov0" title="0">{
        val, err := strconv.Atoi(s)

        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return val</span>
}

// getFormKey is a helper function to make sure the key exists based on the index,
// if it does not, we return an empty string
func getFormKey(data map[string][]string, key string, index int) string <span class="cov0" title="0">{
        if values, ok := data[key]; ok </span><span class="cov0" title="0">{
                if index &gt;= 0 &amp;&amp; index &lt; len(values) </span><span class="cov0" title="0">{
                        return values[index]
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// parseReferenceList takes in *forms.Form and parses the values into an Reference List and returns the list,
// sanitizing any strings along the way
func parseReferenceList(f *forms.Form) *models.ReferenceList <span class="cov0" title="0">{
        var list = models.NewReferenceList()
        if !hasLength(f.Values["resume_reference-list_firstname"]) </span><span class="cov0" title="0">{
                return list
        }</span>

        <span class="cov0" title="0">for i := range f.Values["resume_reference-list_firstname"] </span><span class="cov0" title="0">{
                var item = models.NewReferenceItem()

                item.FirstName = escapeHTML(getFormKey(f.Values, "resume_reference-list_firstname", i))
                item.LastName = escapeHTML(getFormKey(f.Values, "resume_reference-list_lastname", i))
                item.Email = escapeHTML(getFormKey(f.Values, "resume_reference-list_email", i))
                item.PhoneNumber = escapeHTML(getFormKey(f.Values, "resume_reference-list_phonenumber", i))
                item.JobTitle = escapeHTML(getFormKey(f.Values, "resume_reference-list_jobtitle", i))
                item.Organization = escapeHTML(getFormKey(f.Values, "resume_reference-list_organization", i))
                item.Type = escapeHTML(getFormKey(f.Values, "resume_reference-list_type", i))
                item.Address1 = escapeHTML(getFormKey(f.Values, "resume_reference-list_address1", i))
                item.Address2 = escapeHTML(getFormKey(f.Values, "resume_reference-list_address2", i))
                item.City = escapeHTML(getFormKey(f.Values, "resume_reference-list_city", i))
                item.State = escapeHTML(getFormKey(f.Values, "resume_reference-list_state", i))
                item.Zipcode = escapeHTML(getFormKey(f.Values, "resume_reference-list_zipcode", i))
                item.Content = escapeHTML(getFormKey(f.Values, "resume_reference-list_content", i))

                list.ReferenceList = append(list.ReferenceList, item)
        }</span>

        <span class="cov0" title="0">return list</span>
}

// parseAwardsList takes in *forms.Form and parsed the values into an AwardList struct and returns it, sanitizing any strings
func parseAwardsList(f *forms.Form) *models.AwardsList <span class="cov0" title="0">{
        var list = models.NewAwardsList()
        if !hasLength(f.Values["resume_award-list_title"]) </span><span class="cov0" title="0">{
                return list
        }</span>

        <span class="cov0" title="0">for i := range f.Values["resume_award-list_title"] </span><span class="cov0" title="0">{
                var item = models.NewAwardItem()
                item.Title = escapeHTML(getFormKey(f.Values, "resume_award-list_title", i))
                item.OrganizationName = escapeHTML(getFormKey(f.Values, "resume_award-list_name", i))
                item.Year = parseStringToInt(escapeHTML(getFormKey(f.Values, "resume_award-list_year", i)))
                item.Content = escapeHTML(getFormKey(f.Values, "resume_award-list_content", i))

                list.Awards = append(list.Awards, item)
        }</span>

        <span class="cov0" title="0">return list</span>
}

// parseEducationList takes in url values and creates a new education list, santizing along the way

func parseEducationList(f *forms.Form) *models.EducationList <span class="cov0" title="0">{
        var list = models.NewEducationList()
        if !hasLength(f.Values["resume_education-list_name"]) </span><span class="cov0" title="0">{
                return list
        }</span>

        <span class="cov0" title="0">for i := range f.Values["resume_education-list_name"] </span><span class="cov0" title="0">{
                var item = models.NewEducationItem()

                item.Name = escapeHTML(getFormKey(f.Values, "resume_education-list_name", i))
                item.DegreeYear = parseStringToInt(escapeHTML(getFormKey(f.Values, "resume_education-list_degreeyear", i)))
                item.Degree = escapeHTML(getFormKey(f.Values, "resume_education-list_degree", i))
                item.Address1 = escapeHTML(getFormKey(f.Values, "resume_education-list_address1", i))
                item.Address2 = escapeHTML(getFormKey(f.Values, "resume_education-list_address2", i))
                item.City = escapeHTML(getFormKey(f.Values, "resume_education-list_city", i))
                item.State = escapeHTML(getFormKey(f.Values, "resume_education-list_state", i))
                item.Zipcode = escapeHTML(getFormKey(f.Values, "resume_education-list_zipcode", i))

                list.Education = append(list.Education, item)
        }</span>

        <span class="cov0" title="0">return list</span>
}

//        parseEmploymentList takes in url values and creates an new past employment list, sanitizing values along the way

func parseEmploymentList(f *forms.Form) *models.EmploymentList <span class="cov0" title="0">{
        var el = models.NewEmploymentList()
        if !hasLength(f.Values["resume_employment-list_title"]) </span><span class="cov0" title="0">{
                return el
        }</span>

        <span class="cov0" title="0">for i := range f.Values["resume_employment-list_title"] </span><span class="cov0" title="0">{
                var item = models.NewEmploymentListItem()

                item.Title = escapeHTML(getFormKey(f.Values, "resume_employment-list_title", i))
                item.From = parseStringToInt(escapeHTML(getFormKey(f.Values, "resume_employment-list_from_date", i)))
                item.To = parseStringToInt(escapeHTML(getFormKey(f.Values, "resume_employment-list_to_date", i)))
                item.JobTitle = escapeHTML(getFormKey(f.Values, "resume_employment-list_job_title", i))
                item.Summary = escapeHTML(getFormKey(f.Values, "resume_employment-list_summary", i))

                el.Employers = append(el.Employers, item)
        }</span>
        <span class="cov0" title="0">return el</span>
}

// parseFormIntoSkillList takes url values and creates a new skill list, sanitizing values on the way
func parseFormIntoSkillList(fv *forms.Form) *models.SkillList <span class="cov0" title="0">{
        skillList := models.NewSkillList()
        if !hasLength(fv.Values["resume_skill-list_title"]) </span><span class="cov0" title="0">{
                return skillList
        }</span>

        <span class="cov0" title="0">for i := range fv.Values["resume_skill-list_title"] </span><span class="cov0" title="0">{
                item := models.NewSkillListItem()

                item.Title = escapeHTML(getFormKey(fv.Values, "resume_skill-list_title", i))
                dur, err := strconv.Atoi(escapeHTML(getFormKey(fv.Values, "resume_skill-list_duration", i)))
                if err != nil </span><span class="cov0" title="0">{
                        dur = 1
                }</span>
                <span class="cov0" title="0">item.Duration = dur
                item.Content = escapeHTML(getFormKey(fv.Values, "resume_skill-list_content", i))

                skillList.Items = append(skillList.Items, item)</span>
        }
        <span class="cov0" title="0">return skillList</span>
}

// parseFormIntoContactDetails takes in the form values, creates a new contact details struct, and returns it, sanitizing the input values on the way
func parseFormIntoContactDetails(f *url.Values) *models.ContactDetail <span class="cov0" title="0">{

        resContactDetails := models.NewContactDetail()

        resContactDetails.Firstname = html.EscapeString(f.Get("resume_contact-details_firstname"))
        resContactDetails.Lastname = html.EscapeString(f.Get("resume_contact-details_lastname"))
        resContactDetails.AddressLine1 = html.EscapeString(f.Get("resume_contact-details_address1"))
        resContactDetails.AddressLine2 = html.EscapeString(f.Get("resume_contact-details_address2"))
        resContactDetails.City = html.EscapeString(f.Get("resume_contact-details_city"))
        resContactDetails.State = html.EscapeString(f.Get("resume_contact-details_state"))
        resContactDetails.Zipcode = html.EscapeString(f.Get("resume_contact-details_zipcode"))
        resContactDetails.Email = html.EscapeString(f.Get("resume_contact-details_email"))
        resContactDetails.PhoneNumber = html.EscapeString(f.Get("resume_contact-details_phone"))
        resContactDetails.WebAddress = html.EscapeString(f.Get("resume_contact-details_webaddress"))
        return resContactDetails
}</span>

// parseSocialList takes in *forms.Form and parses value into *models.SocialMediaList
// sanitizing any string on the way
func parseSocialList(f *forms.Form) *models.SocialMediaList <span class="cov0" title="0">{
        list := models.NewSocialMediaList()

        if !hasLength(f.Values["resume_social-media_company"]) </span><span class="cov0" title="0">{
                return list
        }</span>

        <span class="cov0" title="0">for i := range f.Values["resume_social-media_company"] </span><span class="cov0" title="0">{
                var listItem = models.NewSocialMediaListItems()

                listItem.CompanyName = escapeHTML(getFormKey(f.Values, "resume_social-media_company", i))
                listItem.UserName = escapeHTML(getFormKey(f.Values, "resume_social-media_username", i))
                listItem.WebAddress = escapeHTML(getFormKey(f.Values, "resume_social-media_address", i))

                list.SocialMediaListItems = append(list.SocialMediaListItems, listItem)
        }</span>
        <span class="cov0" title="0">return list</span>
}

// hasLength takes in a slice of strings and returns whether it has values or not

func hasLength(ss []string) bool <span class="cov0" title="0">{
        if len(ss) &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/pkg/utils"
        "github.com/justinas/nosurf"
)

func (hr *HandlerRepo) HandlePostCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var util = utils.NewUtil()
        csrfToken := r.Header.Get("X-CSRF-TOKEN")

        if !nosurf.VerifyToken(nosurf.Token(r), csrfToken) </span><span class="cov0" title="0">{
                err := errors.New("you are not authorized")
                pl := util.CreateJSONEnvelope("error", err.Error())
                err = json.NewEncoder(w).Encode(pl)
                if err != nil </span><span class="cov0" title="0">{
                        returnErr(w, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">var cat = models.NewCategory()
        err := json.NewDecoder(r.Body).Decode(cat)

        if err != nil </span><span class="cov0" title="0">{
                pl := util.CreateJSONEnvelope("error", err.Error())
                err = json.NewEncoder(w).Encode(pl)
                if err != nil </span><span class="cov0" title="0">{
                        returnErr(w, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if len(cat.Name) &lt; 1 </span><span class="cov0" title="0">{

                errPayload := util.CreateJSONEnvelope("error", errors.New("invalid category name").Error())
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusBadRequest)
                err = json.NewEncoder(w).Encode(errPayload)
                if err != nil </span><span class="cov0" title="0">{
                        returnErr(w, err)
                        return
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">catID, err := hr.conn.InsertCategory(cat)

        if err != nil </span><span class="cov0" title="0">{
                pl := util.CreateJSONEnvelope("error", err.Error())
                err = json.NewEncoder(w).Encode(pl)
                if err != nil </span><span class="cov0" title="0">{
                        returnErr(w, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">cat.ID = catID

        err = json.NewEncoder(w).Encode(cat)

        if err != nil </span><span class="cov0" title="0">{
                pl := util.CreateJSONEnvelope("error", err.Error())
                err = json.NewEncoder(w).Encode(pl)
                if err != nil </span><span class="cov0" title="0">{
                        returnErr(w, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

}
</pre>
		
		<pre class="file" id="file25" style="display: none">package handlers

import (
        "fmt"
        "html"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandlePostCompose(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        err := r.ParseForm()

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">formVals := forms.New(r.Form)

        formVals.Required("title")
        formVals.Required("slug")
        formVals.Required("description")
        formVals.Required("editorContent")
        formVals.Required("editorDelta")

        formVals.MinLength("editorContent", 1)
        formVals.MinLength("description", 1)
        formVals.MinLength("editorDelta", 1)
        if !formVals.Valid() </span><span class="cov0" title="0">{
                cats, err := hr.conn.ListCategories()

                if err != nil </span><span class="cov0" title="0">{
                        hr.app.SessionManager.Put(r.Context(), "error", "there was an error fetching the categories")
                }</span>

                <span class="cov0" title="0">var stringMap = map[string]string{}
                stringMap["pageTitle"] = "Compose"

                var data = map[string]interface{}{}

                data["EditorContent"] = formVals.Get("editorContent")
                data["Categories"] = cats

                render.RenderTemplate(w, r, "compose.gohtml", &amp;models.TemplateData{
                        Form:      formVals,
                        StringMap: stringMap,
                        Data:      data,
                })
                return</span>
        }

        <span class="cov0" title="0">var content = &amp;models.Content{}

        content.Title = html.EscapeString(formVals.Get("title"))
        content.UserId = hr.app.SessionManager.GetInt64(r.Context(), "id")
        content.Slug = html.EscapeString(formVals.Get("slug"))
        if !strings.HasPrefix(content.Slug, "/") </span><span class="cov0" title="0">{
                content.Slug = "/" + content.Slug
        }</span>
        <span class="cov0" title="0">content.Description = html.EscapeString(formVals.Get("description"))
        content.CreatedAt = time.Now()
        content.UpdatedAt = time.Now()
        content.Status = "published"
        content.Version = 1
        content.Content = formVals.Get("editorContent")
        content.Delta = formVals.Get("editorDelta")

        postID, err := hr.conn.InsertEditorContent(content)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">catId, err := strconv.ParseInt(formVals.Get("category"), 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                catId = 0
                hr.app.SessionManager.Put(r.Context(), "warning", "there was an error parsing the category")
                http.Redirect(w, r.WithContext(r.Context()), "/admin", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">catJoinID, err := hr.conn.InsertCategoryPostJoin(&amp;models.CategoryPostJoin{
                CatID:  catId,
                PostID: postID,
        })
        if err != nil </span><span class="cov0" title="0">{
                hr.app.SessionManager.Put(r.Context(), "warning", "failed to save category")
                http.Redirect(w, r.WithContext(r.Context()), "/admin", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">hr.app.SessionManager.Put(r.Context(), "flash", fmt.Sprintf("saved post with id: %d and joined with id: %d", postID, catJoinID))

        http.Redirect(w, r.WithContext(r.Context()), "/admin", http.StatusSeeOther)</span>

}
</pre>
		
		<pre class="file" id="file26" style="display: none">package handlers

import (
        "errors"
        "html"
        "net/http"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/mailer"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandlePostContact(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        stringMap := make(map[string]string)
        stringMap["PageTitle"] = "Contact"
        err := r.ParseForm()

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">f := forms.New(r.Form)

        username := f.Get("username")

        if username != "" </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return

        }</span>

        <span class="cov0" title="0">f.Required("email", "message")

        f.MinLength("email", 3)
        f.MinLength("message", 3)

        isEmail := f.IsEmail(f.Values.Get("email"))

        if !isEmail </span><span class="cov0" title="0">{
                f.Errors.Add("email", "invalid email")
        }</span>

        <span class="cov0" title="0">if !f.Valid() </span><span class="cov0" title="0">{
                render.RenderTemplate(w, r, "contact.gohtml", &amp;models.TemplateData{
                        StringMap: stringMap,
                        Form:      f,
                })
                return
        }</span>

        <span class="cov0" title="0">msg := models.ContactMsg{}

        msg.Email = html.EscapeString(f.Get("email"))
        msg.Message = html.EscapeString(f.Get("message"))
        msg.CreatedAt = time.Now()
        msg.Version = 1

        _, err = hr.conn.InsertMessage(&amp;msg)

        if err != nil </span><span class="cov0" title="0">{
                hr.app.SessionManager.Put(r.Context(), "error", errors.New("error handling the message").Error())
                render.RenderTemplate(w, r, "contact.gohtml", &amp;models.TemplateData{
                        StringMap: stringMap,
                        Form:      f,
                })

        }</span>

        <span class="cov0" title="0">mailData := make(map[string]any)

        mailData["Email"] = msg.Email
        mailData["Message"] = msg.Message

        mail := mailer.NewMailMsgPayload()

        mail.Recipient = "andrew@andrew-mccall.com"
        mail.Data = mailData
        mail.Template = "contact-form.gohtml"

        hr.app.Mailer.MsgChan &lt;- mail

        hr.app.SessionManager.Put(r.Context(), "flash", "Your message was submitted.  I will respond as soon as possible")

        http.Redirect(w, r.WithContext(r.Context()), "/success", http.StatusSeeOther)</span>

}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "os"
        "path/filepath"

        "github.com/elkcityhazard/andrew-mccall-go/pkg/utils"
)

type FileUpload struct {
        OriginalFileName string `json:"original_filename"`
        NewFileName      string `json:"new_filename"`
        FileSize         int64  `json:"filesize"`
        PathToFile       string `json:"path_to_file"`
}

func returnErr(w http.ResponseWriter, err error) <span class="cov0" title="0">{

        type error struct {
                Code  int    `json:"code"`
                Error string `json:"error"`
        }
        var e error
        e.Code = 400
        e.Error = err.Error()
        w.WriteHeader(400)
        if err = json.NewEncoder(w).Encode(e); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

func (hr *HandlerRepo) HandlePostUploadImage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        err := r.ParseMultipartForm(2 &gt;&gt; 30)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">for _, fheader := range r.MultipartForm.File </span><span class="cov0" title="0">{
                for _, hdr := range fheader </span><span class="cov0" title="0">{
                        infile, err := hdr.Open()

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                returnErr(w, err)
                                return
                        }</span>

                        <span class="cov0" title="0">defer infile.Close()
                        f := FileUpload{}
                        f.OriginalFileName = hdr.Filename
                        f.FileSize = hdr.Size

                        var checkFileBuf = make([]byte, 512)

                        infile.Read(checkFileBuf)

                        infile.Seek(0, 0)

                        fileType := http.DetectContentType(checkFileBuf)

                        var allowedFileTypes = []string{"image/png", "image/jpeg", "image/gif", "image/svg+xml"}
                        var isValidFile = false
                        for _, v := range allowedFileTypes </span><span class="cov0" title="0">{
                                if fileType == v </span><span class="cov0" title="0">{
                                        isValidFile = true
                                        break</span>
                                }
                                <span class="cov0" title="0">isValidFile = false</span>
                        }

                        <span class="cov0" title="0">if !isValidFile </span><span class="cov0" title="0">{
                                returnErr(w, errors.New("invalid filetype"))
                                return
                        }</span>

                        <span class="cov0" title="0">fp := fmt.Sprintf("uploads/%d/%s", hr.app.SessionManager.GetInt64(r.Context(), "id"), f.OriginalFileName)

                        // clean to prevent any nefarious doing...
                        fp = filepath.Clean(fp)

                        _, err = os.Stat(filepath.Dir(fp))

                        if err != nil </span><span class="cov0" title="0">{
                                err = os.MkdirAll(filepath.Dir(fp), 0755)

                                if err != nil </span><span class="cov0" title="0">{
                                        returnErr(w, err)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">out, err := os.Create(fp)

                        if err != nil </span><span class="cov0" title="0">{
                                returnErr(w, err)
                                return
                        }</span>
                        <span class="cov0" title="0">defer out.Close()

                        util := utils.NewUtil()

                        err = util.ResizeImage(infile, out, fileType, 968)

                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, err.Error(), http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov0" title="0">newInfo, err := os.Stat(fp)

                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, err.Error(), http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov0" title="0">f.FileSize = newInfo.Size()
                        f.NewFileName = f.OriginalFileName
                        f.PathToFile = "/" + fp // the context of the directory is upload, so we are prefixing a slash for the iamge path

                        if err = json.NewEncoder(w).Encode(f); err != nil </span><span class="cov0" title="0">{
                                returnErr(w, err)
                                return
                        }</span>

                }
        }

}
</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "errors"
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) HandlePostUserActivation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        err := r.ParseForm()

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">token := r.Form.Get("token")
        id := r.Form.Get("id")

        if token == "" || id == "" </span><span class="cov0" title="0">{
                returnErr(w, errors.New("invalid request"))
                return
        }</span>

        <span class="cov0" title="0">user, at, err := hr.conn.GetActivationToken(token)

        if err != nil || at == nil </span><span class="cov0" title="0">{

                if at == nil </span><span class="cov0" title="0">{
                        err = errors.New("invalid token")
                }</span>

                <span class="cov0" title="0">render.RenderTemplate(w, r, "get-user-activation.gohtml", &amp;models.TemplateData{
                        Error: err.Error(),
                })
                return</span>

        }

        <span class="cov0" title="0">activatedUserID, err := hr.conn.ActivateUser(user)

        if err != nil </span><span class="cov0" title="0">{

                render.RenderTemplate(w, r, "get-user-activation.gohtml", &amp;models.TemplateData{
                        Error: err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">hr.app.SessionManager.Put(r.Context(), "id", activatedUserID)

        http.Redirect(w, r.WithContext(r.Context()), "/admin", http.StatusSeeOther)</span>

}
</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"
        "time"

        "github.com/justinas/nosurf"
)

func (hr *HandlerRepo) HandlePutCompose(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        token := r.Header.Get("X-CSRF-TOKEN")
        if !nosurf.VerifyToken(token, nosurf.Token(r)) </span><span class="cov0" title="0">{
                err := errors.New("invalid token")
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">if !hr.app.IsProduction </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
        }</span>

        // create a pointer type to check for what has updated

        <span class="cov0" title="0">type UpdatedContent struct {
                ID            *int64  `json:"ID,omitempty"`
                Title         *string `json:"title,omitempty"`
                Slug          *string `json:"slug,omitempty"`
                Description   *string `json:"description,omitempty"`
                EditorContent *string `json:"editorContent,omitempty"`
                EditorDelta   *string `json:"editorDelta,omitempty"`
                Status        *string `json:"status,omitempty"`
        }

        var c UpdatedContent

        if r.Body != nil </span><span class="cov0" title="0">{
                defer r.Body.Close()

                err := json.NewDecoder(r.Body).Decode(&amp;c)

                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(400)
                        returnErr(w, err)
                        return
                }</span>

                <span class="cov0" title="0">toUpdate, err := hr.conn.GetBlogPostByID(*c.ID)

                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(400)
                        returnErr(w, err)
                        return
                }</span>

                // validate changes

                <span class="cov0" title="0">if c.ID != nil </span><span class="cov0" title="0">{
                        toUpdate.ID = *c.ID
                }</span>

                <span class="cov0" title="0">if c.Title != nil </span><span class="cov0" title="0">{
                        toUpdate.Title = *c.Title
                }</span>

                <span class="cov0" title="0">if c.Slug != nil </span><span class="cov0" title="0">{
                        toUpdate.Slug = *c.Slug
                }</span>

                <span class="cov0" title="0">if c.Description != nil </span><span class="cov0" title="0">{
                        toUpdate.Description = *c.Description
                }</span>

                <span class="cov0" title="0">if c.EditorContent != nil </span><span class="cov0" title="0">{
                        toUpdate.Content = *c.EditorContent
                }</span>

                <span class="cov0" title="0">if c.EditorDelta != nil </span><span class="cov0" title="0">{
                        toUpdate.Delta = *c.EditorDelta
                }</span>

                <span class="cov0" title="0">if c.Status != nil </span><span class="cov0" title="0">{
                        toUpdate.Status = *c.Status
                }</span>

                <span class="cov0" title="0">toUpdate.UpdatedAt = time.Now()

                // handle update op

                affected, err := hr.conn.UpdatePost(toUpdate)

                if err != nil </span><span class="cov0" title="0">{
                        returnErr(w, err)
                        return
                }</span>

                <span class="cov0" title="0">if affected &gt; 0 </span><span class="cov0" title="0">{
                        toUpdate.Version = toUpdate.Version + 1
                }</span>

                <span class="cov0" title="0">w.WriteHeader(200)
                err = json.NewEncoder(w).Encode(toUpdate)

                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(500)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>

        } else<span class="cov0" title="0"> {
                returnErr(w, errors.New("no op"))
        }</span>

}
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/config"
        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
        "github.com/elkcityhazard/andrew-mccall-go/internal/repository"
)

type CtxKey struct{}

func GetField(r *http.Request, index int) string <span class="cov0" title="0">{
        fields := r.Context().Value(CtxKey{}).([]string)
        return fields[index]
}</span>

type HandlerRepo struct {
        app  *config.AppConfig
        conn repository.DBServicer
}

var Repo *HandlerRepo

func NewHandlerRepo(a *config.AppConfig, servicer repository.DBServicer) *HandlerRepo <span class="cov0" title="0">{
        return &amp;HandlerRepo{
                app:  a,
                conn: servicer,
        }
}</span>

func SetHandlerRepo(hr *HandlerRepo) <span class="cov0" title="0">{
        Repo = hr
}</span>

func (hr *HandlerRepo) HomeGetHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        data := map[string]interface{}{}

        posts, err := hr.conn.ListPosts(3, 0)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">data["Posts"] = posts

        stringMap := make(map[string]string)

        stringMap["PageTitle"] = "Home"

        var td = &amp;models.TemplateData{
                StringMap: stringMap,
                Data:      data,
        }
        render.RenderTemplate(w, r, "home.gohtml", td)
        return</span>

}

func (hr *HandlerRepo) CreateEmptyTemplatePayload() (map[string]any, map[string]string, map[string]int, *forms.Form) <span class="cov0" title="0">{
        dataMap := make(map[string]any)
        stringMap := make(map[string]string)
        intMap := make(map[string]int)
        form := forms.New(nil)

        return dataMap, stringMap, intMap, form
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "net/http"
)

func HandleStatic(w http.ResponseWriter, r *http.Request) {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "fmt"
        "html/template"
        "net/http"
        "strings"
        "time"

        "github.com/alexedwards/argon2id"
        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/mailer"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
        "github.com/elkcityhazard/andrew-mccall-go/pkg/utils"
)

func (hr *HandlerRepo) HandlePostSignup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        err := r.ParseForm()

        const (
                minPWLength = 8
        )

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">f := forms.New(r.Form)

        f.Required("email", "username", "password1", "password2")

        f.MinLength("email", 4)
        f.MinLength("username", 6)
        f.MinLength("password1", minPWLength)
        f.MinLength("password2", minPWLength)

        isEmail := f.IsEmail(f.Get("email"))

        if !isEmail </span><span class="cov0" title="0">{
                f.Errors.Add("email", "invalid email signature")
        }</span>

        <span class="cov0" title="0">if !strings.EqualFold(f.Get("password1"), f.Get("password2")) </span><span class="cov0" title="0">{
                f.Errors.Add("password1", "passwords do not match")
                f.Errors.Add("password2", "passwords do not match")
        }</span>

        <span class="cov0" title="0">var util = utils.NewUtil()

        isComplexPW := util.CheckPWStrength(f.Get("password1"), minPWLength)

        if !isComplexPW </span><span class="cov0" title="0">{
                f.Errors.Add("password1", "invalid password")
                f.Errors.Add("password2", "invalid password")
        }</span>

        <span class="cov0" title="0">user, _ := hr.conn.GetUserByEmail(f.Get("email"))

        if user != nil </span><span class="cov0" title="0">{
                f.Errors.Add("email", "invalid entry")
        }</span>

        <span class="cov0" title="0">if !f.Valid() </span><span class="cov0" title="0">{

                stringMap := make(map[string]string)
                stringMap["PageTitle"] = "Singup"
                render.RenderTemplate(w, r, "signup.gohtml", &amp;models.TemplateData{
                        StringMap: stringMap,
                        Form:      f,
                })
                return
        }</span>

        // handle user creation

        <span class="cov0" title="0">var newUser = &amp;models.User{}

        var newPW = &amp;models.Password{}

        newUser.Email = f.Get("email")
        newUser.Username = f.Get("username")
        newUser.CreatedAt = time.Now()
        newUser.UpdatedAt = time.Now()
        newUser.IsActive = false
        newUser.Role = "user"
        newUser.Version = 1

        hash, err := argon2id.CreateHash(f.Get("password1"), argon2id.DefaultParams)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">newPW.Hash = hash
        newPW.PlainText = f.Get("password1")
        newPW.CreatedAt = time.Now()
        newPW.UpdatedAt = time.Now()
        newPW.IsActive = false
        newPW.Version = 1
        newUser.Password = newPW

        insertedUser, err := hr.conn.InsertUser(newUser)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">newUser.ID = insertedUser

        at := models.NewActivationToken()

        err = at.GenerateToken(insertedUser, time.Hour*48, "user")

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">_, err = hr.conn.InsertActivationToken(at)

        if err != nil </span><span class="cov0" title="0">{
                returnErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">var mailMsg = &amp;mailer.MailMsgPayload{}

        mailMsg.Recipient = newUser.Email
        mailMsg.Template = "welcome.gohtml"

        mailData := make(map[string]any)

        mailData["Email"] = newUser.Email

        if !hr.app.IsProduction </span><span class="cov0" title="0">{
                mailData["ActivationLink"] = template.HTML(fmt.Sprintf("http://localhost:8080/users/activation?token=%s&amp;id=%d", at.Plaintext, at.UserID))

        }</span> else<span class="cov0" title="0"> {
                mailData["ActivationLink"] = template.HTML(fmt.Sprintf("https://www.andrew-mccall.com/users/activation?token=%s&amp;id=%d", at.Plaintext, at.UserID))
        }</span>

        <span class="cov0" title="0">mailMsg.Data = mailData

        hr.app.Mailer.MsgChan &lt;- mailMsg
        hr.app.SessionManager.Put(r.Context(), "id", insertedUser)

        http.Redirect(w, r.WithContext(r.Context()), "/signup/success", http.StatusSeeOther)</span>

}
</pre>
		
		<pre class="file" id="file33" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) LoginGetHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var stringMap = make(map[string]string)
        stringMap["Title"] = "Login"
        switch r.Method </span>{
        case "GET":<span class="cov0" title="0">

                render.RenderTemplate(w, r, "login.gohtml", &amp;models.TemplateData{
                        StringMap: stringMap,
                        Form:      forms.New(nil),
                })</span>
        case "POST":<span class="cov0" title="0"></span>

        default:<span class="cov0" title="0">
                http.NotFound(w, r)</span>
        }

}
</pre>
		
		<pre class="file" id="file34" style="display: none">package handlers

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/alexedwards/argon2id"
        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) LoginPostHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var stringMap = map[string]string{}

        err := r.ParseForm()

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">form := forms.New(r.Form)

        form.Required("email", "password")

        form.MinLength("email", 2)

        form.MinLength("password", 8)

        isValidEmail := form.IsEmail(form.Get("email"))

        if !isValidEmail </span><span class="cov0" title="0">{
                form.Errors.Add("email", "invalid email provided")
        }</span>

        <span class="cov0" title="0">if !form.Valid() </span><span class="cov0" title="0">{

                render.RenderTemplate(w, r, "login.gohtml", &amp;models.TemplateData{
                        StringMap: stringMap,
                        Form:      form,
                })
                return
        }</span>

        <span class="cov0" title="0">u, err := hr.conn.GetUserByEmail(form.Get("email"))

        if err != nil </span><span class="cov0" title="0">{

                form.Errors.Add("email", "something went wrong")
                form.Errors.Add("password", "something went wrong")

                render.RenderTemplate(w, r, "login.gohtml", &amp;models.TemplateData{
                        StringMap: stringMap,
                        Form:      form,
                })
                return
        }</span>

        <span class="cov0" title="0">if !u.IsActive </span><span class="cov0" title="0">{
                returnErr(w, errors.New("something went wrong"))
                return
        }</span>

        <span class="cov0" title="0">passwordIsValid, err := argon2id.ComparePasswordAndHash(form.Get("password"), u.Password.Hash)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if !passwordIsValid </span><span class="cov0" title="0">{
                form.Errors.Add("password", "invalid credentials, try again")
                form.Errors.Add("email", "invalid credentials, try again.")
        }</span>

        <span class="cov0" title="0">if !form.Valid() </span><span class="cov0" title="0">{

                render.RenderTemplate(w, r, "login.gohtml", &amp;models.TemplateData{
                        StringMap: stringMap,
                        Form:      form,
                })
                return
        }</span>

        <span class="cov0" title="0">hr.app.SessionManager.Put(r.Context(), "id", u.ID)
        hr.app.SessionManager.Put(r.Context(), "flash", fmt.Sprintf("Welcome, %s", u.Email))

        http.Redirect(w, r.WithContext(r.Context()), "/admin", http.StatusSeeOther)</span>

}
</pre>
		
		<pre class="file" id="file35" style="display: none">package handlers

import (
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/forms"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/elkcityhazard/andrew-mccall-go/internal/render"
)

func (hr *HandlerRepo) SignupGetHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var stringMap = map[string]string{}

        stringMap["Title"] = "Signup"

        render.RenderTemplate(w, r, "signup.gohtml", &amp;models.TemplateData{
                StringMap: stringMap,
                Form:      forms.New(nil),
        })
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package mailer

import (
        "bytes"
        "embed"
        "fmt"
        "html/template"
        "log"
        "sync"
        "time"

        "github.com/go-mail/mail/v2"
)

//go:embed templates
var mailTemplateFS embed.FS

type Mailer struct {
        Dialer   *mail.Dialer
        Sender   string
        MsgChan  chan *MailMsgPayload
        ErrChan  chan error
        DoneChan chan bool
        WG       *sync.WaitGroup
}

type MailMsgPayload struct {
        Recipient string
        Template  string
        Data      any
}

func NewMailMsgPayload() *MailMsgPayload <span class="cov0" title="0">{
        return &amp;MailMsgPayload{}
}</span>

// New Creates a new mailer

func New(host string, port int, username, password, sender string) Mailer <span class="cov0" title="0">{
        dialer := mail.NewDialer(host, port, username, password)
        dialer.Timeout = time.Second * 5

        return Mailer{
                Dialer:   dialer,
                Sender:   sender,
                MsgChan:  make(chan *MailMsgPayload),
                ErrChan:  make(chan error),
                DoneChan: make(chan bool),
        }
}</span>

func (m Mailer) ListenForIncomingEmail() <span class="cov0" title="0">{
        fmt.Println("Listening for mail")
        for </span><span class="cov0" title="0">{
                select </span>{
                case msg := &lt;-m.MsgChan:<span class="cov0" title="0">
                        fmt.Println("hit the route")
                        m.SendEmail(msg.Recipient, msg.Template, msg.Data)</span>
                case err := &lt;-m.ErrChan:<span class="cov0" title="0">
                        log.Println(err.Error())</span>
                case &lt;-m.DoneChan:<span class="cov0" title="0">
                        close(m.MsgChan)
                        close(m.ErrChan)
                        close(m.DoneChan)
                        return</span>
                }
        }

}

func (m Mailer) SendEmail(recipient, templateFile string, data any) error <span class="cov0" title="0">{
        // parse the template
        tmpl, err := template.New("email").ParseFS(mailTemplateFS, "templates/"+templateFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">subject := &amp;bytes.Buffer{}

        err = tmpl.ExecuteTemplate(subject, "subject", data)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">plainBody := &amp;bytes.Buffer{}

        err = tmpl.ExecuteTemplate(plainBody, "plainBody", data)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">htmlBody := &amp;bytes.Buffer{}

        err = tmpl.ExecuteTemplate(htmlBody, "htmlBody", data)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">msg := mail.NewMessage()
        msg.SetHeader("To", recipient)
        msg.SetHeader("From", m.Sender)
        msg.SetHeader("Subject", subject.String())
        msg.SetBody("text/plain", plainBody.String())
        msg.AddAlternative("text/html", htmlBody.String())

        err = m.Dialer.DialAndSend(msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m.DoneChan &lt;- true

        return nil</span>

}
</pre>
		
		<pre class="file" id="file37" style="display: none">package models

import "time"

type Category struct {
        ID        int64     `json:"category_id"`
        Name      string    `json:"category_name"`
        CreatedAt time.Time `json:"category_created_at"`
        UpdatedAt time.Time `json:"category_updated_at"`
        Version   int       `json:"category_version"`
}

func NewCategory() *Category <span class="cov0" title="0">{
        return &amp;Category{
                Name:      "",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type CategoryPostJoin struct {
        ID     int64
        CatID  int64
        PostID int64
}

func NewCategoryPostJoin(catID, postID int64) *CategoryPostJoin <span class="cov0" title="0">{
        return &amp;CategoryPostJoin{
                CatID:  catID,
                PostID: postID,
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package models

import "encoding/json"

type Ops struct {
        Attributes struct {
                Header     int    `json:"header,omitempty"`
                Bold       bool   `json:"bold,omitempty"`
                Italic     bool   `json:"italic,omitempty"`
                Underline  bool   `json:"underline,omitempty"`
                Strike     bool   `json:"strike,omitempty"`
                Blockquote bool   `json:"blockquote,omitempty"`
                CodeBlock  string `json:"code-block,omitempty"`
                Link       string `json:"link,omitempty"`
                Image      string `json:"image,omitempty"`
        } `json:"attributes,omitempty"`
        Insert json.RawMessage `json:"insert,omitempty"`
}

func NewOps() *Ops <span class="cov0" title="0">{
        return &amp;Ops{}
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package models

import "time"

// Resume holds all resume elements together
type Resume struct {
        ID              int64
        UserID          int64
        JobTitle        string           // parsed
        ContactDetail   *ContactDetail   // parsed
        SocialMediaList *SocialMediaList // parsed
        Objective       *Objective       // parsed
        SkillList       *SkillList       // parsed
        EmploymentList  *EmploymentList  // parsed
        EducationList   *EducationList   // parsed
        AwardsList      *AwardsList
        ReferenceList   *ReferenceList
        CreatedAt       time.Time
        UpdatedAt       time.Time
        Version         int
}

// NewResume returns a resume  model with created_at. updated_at, and version pre-populated
func NewResume() *Resume <span class="cov0" title="0">{
        return &amp;Resume{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type ReferenceItem struct {
        ID              int64
        ReferenceListID int64
        FirstName       string
        LastName        string
        Email           string
        PhoneNumber     string
        JobTitle        string
        Organization    string
        Type            string
        Address1        string
        Address2        string
        City            string
        State           string
        Zipcode         string
        Content         string
        CreatedAt       time.Time
        UpdatedAt       time.Time
        Version         int
}

func NewReferenceItem() *ReferenceItem <span class="cov0" title="0">{
        return &amp;ReferenceItem{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type ReferenceList struct {
        ID            int64
        ResumeID      int64
        ReferenceList []*ReferenceItem
        CreatedAt     time.Time
        UpdatedAt     time.Time
        Version       int
}

func NewReferenceList() *ReferenceList <span class="cov0" title="0">{
        return &amp;ReferenceList{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type AwardItem struct {
        ID               int64
        AwardListID      int64
        Title            string
        OrganizationName string
        Year             int
        Content          string
        CreatedAt        time.Time
        UpdatedAt        time.Time
        Version          int
}

func NewAwardItem() *AwardItem <span class="cov0" title="0">{
        return &amp;AwardItem{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type AwardsList struct {
        ID        int64
        ResumeID  int64
        Awards    []*AwardItem
        CreatedAt time.Time
        UpdatedAt time.Time
        Version   int
}

func NewAwardsList() *AwardsList <span class="cov0" title="0">{
        return &amp;AwardsList{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type EducationList struct {
        ID        int64
        ResumeID  int64
        Education []*EducationItem
        CreatedAt time.Time
        UpdatedAt time.Time
        Version   int
}

func NewEducationList() *EducationList <span class="cov0" title="0">{
        return &amp;EducationList{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type EducationItem struct {
        ID              int64
        EducationListID int64
        Name            string
        DegreeYear      int
        Degree          string
        Address1        string
        Address2        string
        City            string
        State           string
        Zipcode         string
        CreatedAt       time.Time
        UpdatedAt       time.Time
        Version         int
}

func NewEducationItem() *EducationItem <span class="cov0" title="0">{
        return &amp;EducationItem{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type EmploymentListItem struct {
        ID               int64
        EmploymentListID int64
        Title            string
        From             int
        To               int
        JobTitle         string
        Summary          string
        CreatedAt        time.Time
        UpdatedAt        time.Time
        Version          int
}

func NewEmploymentListItem() *EmploymentListItem <span class="cov0" title="0">{
        return &amp;EmploymentListItem{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type EmploymentList struct {
        ID        int64
        ResumeID  int64
        Employers []*EmploymentListItem
        CreatedAt time.Time
        UpdatedAt time.Time
        Version   int
}

func NewEmploymentList() *EmploymentList <span class="cov0" title="0">{
        return &amp;EmploymentList{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type SkillList struct {
        ID        int64
        ResumeID  int64
        Title     string
        Items     []*SkillListItem
        CreatedAt time.Time
        UpdatedAt time.Time
        Version   int
}

func NewSkillList() *SkillList <span class="cov0" title="0">{
        return &amp;SkillList{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type SkillListItem struct {
        ID          int64
        SKillListID int64
        Title       string
        Content     string
        Duration    int
        CreatedAt   time.Time
        UpdatedAt   time.Time
        Version     int
}

func NewSkillListItem() *SkillListItem <span class="cov0" title="0">{
        return &amp;SkillListItem{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type Objective struct {
        ID        int64
        ResumeID  int64
        Content   string
        CreatedAt time.Time
        UpdatedAt time.Time
        Version   int
}

func NewObjective() *Objective <span class="cov0" title="0">{
        return &amp;Objective{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type SocialMediaList struct {
        ID                   int64
        ResumeID             int64
        SocialMediaListItems []*SocialMediaListItems
        CreatedAt            time.Time
        UpdatedAt            time.Time
        Version              int
}

func NewSocialMediaList() *SocialMediaList <span class="cov0" title="0">{
        return &amp;SocialMediaList{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type SocialMediaListItems struct {
        ID                int64
        SocialMediaListID int64
        CompanyName       string
        UserName          string
        WebAddress        string
        CreatedAt         time.Time
        UpdatedAt         time.Time
        Version           int
}

func NewSocialMediaListItems() *SocialMediaListItems <span class="cov0" title="0">{
        return &amp;SocialMediaListItems{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>

type ContactDetail struct {
        ID           int64
        ResumeID     int64
        Firstname    string
        Lastname     string
        AddressLine1 string
        AddressLine2 string
        City         string
        State        string
        Zipcode      string
        Email        string
        PhoneNumber  string
        WebAddress   string
        CreatedAt    time.Time
        UpdatedAt    time.Time
        Version      int
}

func NewContactDetail() *ContactDetail <span class="cov0" title="0">{
        return &amp;ContactDetail{
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Version:   1,
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package models

import "github.com/elkcityhazard/andrew-mccall-go/internal/forms"

type TemplateData struct {
        SiteTitle       string
        StringMap       map[string]string
        IntMap          map[string]int
        FloatMap        map[string]float32
        BoolMap         map[string]bool
        Data            map[string]any
        Form            *forms.Form
        CSRFToken       string
        IsAuthenticated bool
        Flash           string
        Warning         string
        Error           string
}

type MenuItem struct {
        URL   string
        Title string
}

func (td *TemplateData) PopulateAdminMenu() <span class="cov0" title="0">{

        var menu []*MenuItem

        menu = append(menu, &amp;MenuItem{
                URL:   "/admin",
                Title: "Admin Home",
        })

        menu = append(menu, &amp;MenuItem{
                URL:   "/admin/compose",
                Title: "Compose New",
        })

        menu = append(menu, &amp;MenuItem{
                URL:   "/admin/categories",
                Title: "Manage Categories",
        })

        menu = append(menu, &amp;MenuItem{
                URL:   "/admin/resume",
                Title: "Edit Resume",
        })

        if td.Data == nil </span><span class="cov0" title="0">{
                td.Data = make(map[string]any)
        }</span>

        <span class="cov0" title="0">td.Data["AdminMenu"] = menu</span>

}
</pre>
		
		<pre class="file" id="file41" style="display: none">package models

import (
        "crypto/rand"
        "crypto/sha256"
        "encoding/base32"
        "time"
)

type Password struct {
        ID        int64
        PlainText string
        Hash      string
        CreatedAt time.Time
        UpdatedAt time.Time
        IsActive  bool
        Version   int64
}

type User struct {
        ID        int64
        Email     string
        Username  string
        Password  *Password
        CreatedAt time.Time
        UpdatedAt time.Time
        IsActive  bool
        Role      string
        Version   int64
}

type ActivationToken struct {
        ID        int64
        Plaintext string
        Hash      []byte
        UserID    int64
        Expiry    time.Time
        Scope     string
}

func NewActivationToken() *ActivationToken <span class="cov0" title="0">{
        return &amp;ActivationToken{}
}</span>

func (at *ActivationToken) GenerateToken(userID int64, ttl time.Duration, scope string) error <span class="cov0" title="0">{
        at.UserID = userID
        at.Expiry = time.Now().Add(ttl)
        at.Scope = scope

        randomBytes := make([]byte, 16)

        _, err := rand.Read(randomBytes)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">at.Plaintext = base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(randomBytes)

        hash := sha256.Sum256([]byte(at.Plaintext))
        at.Hash = hash[:]

        return nil</span>

}
</pre>
		
		<pre class="file" id="file42" style="display: none">package render

import (
        "bytes"
        "errors"
        "log"
        "net/http"

        "github.com/elkcityhazard/andrew-mccall-go/internal/config"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
        "github.com/justinas/nosurf"
)

var app *config.AppConfig

func NewRenderer(a *config.AppConfig) <span class="cov0" title="0">{
        app = a
}</span>

func AddDefaultTemplateData(td *models.TemplateData, r *http.Request) *models.TemplateData <span class="cov0" title="0">{

        if td == nil </span><span class="cov0" title="0">{
                td = &amp;models.TemplateData{}
        }</span>

        <span class="cov0" title="0">if td.StringMap == nil </span><span class="cov0" title="0">{
                td.StringMap = make(map[string]string)
        }</span>
        <span class="cov0" title="0">if td.StringMap["PageTitle"] == "" </span><span class="cov0" title="0">{
                td.StringMap["PageTitle"] = app.SiteTitle
        }</span>

        <span class="cov0" title="0">td.SiteTitle = app.SiteTitle
        td.IsAuthenticated = app.SessionManager.Exists(r.Context(), "id")
        td.CSRFToken = nosurf.Token(r)
        td.Error = app.SessionManager.PopString(r.Context(), "error")
        td.Flash = app.SessionManager.PopString(r.Context(), "flash")
        td.Warning = app.SessionManager.PopString(r.Context(), "warning")

        td.PopulateAdminMenu()

        return td</span>

}

func RenderTemplate(w http.ResponseWriter, r *http.Request, tmpl string, td *models.TemplateData) <span class="cov0" title="0">{

        td = AddDefaultTemplateData(td, r)

        var buf = new(bytes.Buffer)

        t, ok := app.TemplateCache[tmpl]

        if !ok </span><span class="cov0" title="0">{
                log.Panic(errors.New("error with template cache"))
                return
        }</span>

        <span class="cov0" title="0">err := t.Execute(buf, td)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>

        <span class="cov0" title="0">_, err = buf.WriteTo(w)

        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>

}
</pre>
		
		<pre class="file" id="file43" style="display: none">package sqldbconn

import (
        "context"
        "database/sql"
        "errors"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) DeletePostById(id, userID int64) (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)
        defer cancel()

        affectedChan := make(chan int64)
        errChan := make(chan error)
        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(affectedChan)
                defer close(errChan)

                tx, err := sdc.conn.BeginTx(ctx, &amp;sql.TxOptions{})

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

                // check user owns document
                <span class="cov0" title="0">gpStmt := `SELECT posts.id,posts.user_id from posts WHERE posts.id = ?`

                var p models.Content

                err = sdc.conn.QueryRowContext(ctx, gpStmt, id).Scan(&amp;p.ID, &amp;p.UserId)

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">if p.UserId != userID </span><span class="cov0" title="0">{
                        tx.Rollback()
                        err := errors.New("you are not authorized")
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">stmt := `DELETE FROM posts WHERE posts.id = ?`

                args := []any{id}

                result, err := sdc.conn.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">affected, err := result.RowsAffected()

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">affectedChan &lt;- affected

                err = tx.Commit()

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return 0, err</span>
        case affected := &lt;-affectedChan:<span class="cov0" title="0">
                return affected, nil</span>
        }

}
</pre>
		
		<pre class="file" id="file44" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetAwardItems(resumeID int64) (*models.AwardsList, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        awardListChan := make(chan *models.AwardsList)
        errChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(awardListChan)
                defer close(errChan)

                stmt := `
                select
                        award_lists.id,
                        award_lists.resume_id,
                        award_lists.created_at,
                        award_lists.updated_at,
                        award_lists.version,
                        award_items.id,
                        award_items.award_list_id,
                        award_items.title,
                        award_items.org_name,
                        award_items.received_year,
                        award_items.content,
                        award_items.created_at,
                        award_items.updated_at,
                        award_items.version
                FROM award_lists
                INNER JOIN
                        award_items ON award_items.award_list_id =award_list_id 
                WHERE award_lists.resume_id = ?
                ORDER BY award_items.created_at ASC;
                `

                args := []any{resumeID}

                rows, err := sdc.conn.QueryContext(ctx, stmt, args...)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">defer rows.Close()

                awList := models.AwardsList{}

                for rows.Next() </span><span class="cov0" title="0">{

                        awItem := models.AwardItem{}

                        err := rows.Scan(
                                &amp;awList.ID,
                                &amp;awList.ResumeID,
                                &amp;awList.CreatedAt,
                                &amp;awList.UpdatedAt,
                                &amp;awList.Version,
                                &amp;awItem.ID,
                                &amp;awItem.AwardListID,
                                &amp;awItem.Title,
                                &amp;awItem.OrganizationName,
                                &amp;awItem.Year,
                                &amp;awItem.Content,
                                &amp;awItem.CreatedAt,
                                &amp;awItem.UpdatedAt,
                                &amp;awItem.Version,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">awList.Awards = append(awList.Awards, &amp;awItem)</span>

                }

                <span class="cov0" title="0">awardListChan &lt;- &amp;awList</span>
        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case awList := &lt;-awardListChan:<span class="cov0" title="0">
                return awList, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetCategoryByPostID(postID int64) (*models.Category, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        catChan := make(chan *models.Category)
        errChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(catChan)
                defer close(errChan)

                stmt := `
                SELECT categories.id,categories.name,categories.created_at, categories.updated_at,categories.version FROM categories
                INNER JOIN category_joins
                ON category_joins.post_id = ?
                `

                c := &amp;models.Category{}

                err := sdc.conn.QueryRowContext(ctx, stmt, postID).Scan(&amp;c.ID, &amp;c.Name, &amp;c.CreatedAt, &amp;c.UpdatedAt, &amp;c.Version)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">catChan &lt;- c</span>

        }()

        <span class="cov0" title="0">select </span>{
        case cat := &lt;-catChan:<span class="cov0" title="0">
                return cat, nil</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

}
</pre>
		
		<pre class="file" id="file46" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetEducationList(resumeID int64) (*models.EducationList, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()
        sdc.app.WG.Add(1)
        eduListChan := make(chan *models.EducationList)
        errChan := make(chan error)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(eduListChan)
                defer close(errChan)

                stmt := `
                select
        education_lists.id,
        education_lists.resume_id,
        education_lists.created_at,
        education_lists.updated_at,
        education_lists.version,
        education_items.id,
        education_items.education_lists_id,
        education_items.name,
        education_items.degree_year,
        education_items.degree,
        education_items.address_1,
        education_items.address_2,
        education_items.city,
        education_items.state,
        education_items.zipcode,
        education_items.created_at,
        education_items.updated_at,
        education_items.version
FROM education_lists
INNER JOIN education_items
ON education_items.education_lists_id = education_lists.id
WHERE education_lists.resume_id = ?
ORDER BY education_items.created_at ASC;
                `

                args := []any{resumeID}

                rows, err := sdc.conn.QueryContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">defer rows.Close()

                eduList := models.EducationList{}

                for rows.Next() </span><span class="cov0" title="0">{
                        eduItem := models.EducationItem{}

                        err := rows.Scan(
                                &amp;eduList.ID,
                                &amp;eduList.ResumeID,
                                &amp;eduList.CreatedAt,
                                &amp;eduList.UpdatedAt,
                                &amp;eduList.Version,
                                &amp;eduItem.ID,
                                &amp;eduItem.EducationListID,
                                &amp;eduItem.Name,
                                &amp;eduItem.DegreeYear,
                                &amp;eduItem.Degree,
                                &amp;eduItem.Address1,
                                &amp;eduItem.Address2,
                                &amp;eduItem.City,
                                &amp;eduItem.State,
                                &amp;eduItem.Zipcode,
                                &amp;eduItem.CreatedAt,
                                &amp;eduItem.UpdatedAt,
                                &amp;eduItem.Version,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">eduList.Education = append(eduList.Education, &amp;eduItem)</span>

                }

                <span class="cov0" title="0">eduListChan &lt;- &amp;eduList</span>
        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case eduList := &lt;-eduListChan:<span class="cov0" title="0">
                return eduList, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

}
</pre>
		
		<pre class="file" id="file47" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetEmploymentList(resumeID int64) (*models.EmploymentList, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        empListChan := make(chan *models.EmploymentList)
        errChan := make(chan error)
        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(empListChan)
                defer close(errChan)

                stmt := `
                select
                        employment_lists.id,
                        employment_lists.resume_id,
                        employment_lists.created_at,
                        employment_lists.updated_at,
                        employment_lists.version,
                        employment_list_items.id,
                        employment_list_items.employment_lists_id,
                        employment_list_items.title as employment_list_item_org_title,
                        employment_list_items.date_from,
                        employment_list_items.date_to,
                        employment_list_items.job_title as employment_list_item_job_title,
                        employment_list_items.summary,
                        employment_list_items.created_at,
                        employment_list_items.updated_at,
                        employment_list_items.version
                FROM employment_lists
                INNER JOIN employment_list_items
                ON employment_list_items.employment_lists_id = employment_lists.id
                WHERE employment_lists.resume_id = ?
                ORDER BY employment_list_items.created_at ASC
                        `

                args := []any{resumeID}

                rows, err := sdc.conn.QueryContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">defer rows.Close()

                empList := models.EmploymentList{}

                for rows.Next() </span><span class="cov0" title="0">{

                        empListItem := models.EmploymentListItem{}

                        err := rows.Scan(
                                &amp;empList.ID,
                                &amp;empList.ResumeID,
                                &amp;empList.CreatedAt,
                                &amp;empList.UpdatedAt,
                                &amp;empList.Version,
                                &amp;empListItem.ID,
                                &amp;empListItem.EmploymentListID,
                                &amp;empListItem.Title,
                                &amp;empListItem.From,
                                &amp;empListItem.To,
                                &amp;empListItem.JobTitle,
                                &amp;empListItem.Summary,
                                &amp;empListItem.CreatedAt,
                                &amp;empListItem.UpdatedAt,
                                &amp;empListItem.Version,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">empList.Employers = append(empList.Employers, &amp;empListItem)</span>
                }

                <span class="cov0" title="0">empListChan &lt;- &amp;empList</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case empList := &lt;-empListChan:<span class="cov0" title="0">
                return empList, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

}
</pre>
		
		<pre class="file" id="file48" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetReferenceList(resumeID int64) (*models.ReferenceList, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        sdc.app.WG.Add(1)
        refListChan := make(chan *models.ReferenceList)
        errChan := make(chan error)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(refListChan)
                defer close(errChan)

                stmt := `
                SELECT 
 reference_lists.id,
 reference_lists.resume_id,
 reference_lists.created_at,
 reference_lists.updated_at,
 reference_lists.version,
 reference_items.id,
 reference_items.ref_list_id,
 reference_items.first_name,
 reference_items.last_name,
 reference_items.email,
 reference_items.phone_number,
 reference_items.job_title,
 reference_items.organization,
 reference_items.type,
 reference_items.address_1,
 reference_items.address_2,
 reference_items.city,
 reference_items.state,
 reference_items.zipcode,
 reference_items.content,
 reference_items.created_at,
 reference_items.updated_at,
 reference_items.version
 FROM reference_lists
 INNER JOIN
 reference_items
 ON reference_items.ref_list_id = reference_lists.id
 WHERE reference_lists.resume_id = ?
 ORDER BY reference_items.created_at ASC;
                `

                args := []any{resumeID}

                rows, err := sdc.conn.QueryContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">defer rows.Close()

                refList := models.ReferenceList{}

                for rows.Next() </span><span class="cov0" title="0">{

                        refItem := models.ReferenceItem{}

                        err := rows.Scan(
                                &amp;refList.ID,
                                &amp;refList.ResumeID,
                                &amp;refList.CreatedAt,
                                &amp;refList.UpdatedAt,
                                &amp;refList.Version,
                                &amp;refItem.ID,
                                &amp;refItem.ReferenceListID,
                                &amp;refItem.FirstName,
                                &amp;refItem.LastName,
                                &amp;refItem.Email,
                                &amp;refItem.PhoneNumber,
                                &amp;refItem.JobTitle,
                                &amp;refItem.Organization,
                                &amp;refItem.Type,
                                &amp;refItem.Address1,
                                &amp;refItem.Address2,
                                &amp;refItem.City,
                                &amp;refItem.State,
                                &amp;refItem.Zipcode,
                                &amp;refItem.Content,
                                &amp;refItem.CreatedAt,
                                &amp;refItem.UpdatedAt,
                                &amp;refItem.Version,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">refList.ReferenceList = append(refList.ReferenceList, &amp;refItem)</span>

                }

                <span class="cov0" title="0">refListChan &lt;- &amp;refList</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case refList := &lt;-refListChan:<span class="cov0" title="0">
                return refList, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

}
</pre>
		
		<pre class="file" id="file49" style="display: none">package sqldbconn

import (
        "context"
        "database/sql"
        "errors"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetResumeById(userID int64) (*models.Resume, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        resumeChan := make(chan *models.Resume)
        errorChan := make(chan error)

        sdc.app.WG.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(resumeChan)
                defer close(errorChan)

                stmt := `
                select 
                resumes.id as resume_id,
                resumes.user_id as resume_user_id,
                resumes.job_title as resume_job_title,
                resumes.created_at as resume_created_at,
                resumes.updated_at as resume_updated_at,
                resumes.version as resume_version
                FROM resumes WHERE id = ?
                `
                args := []any{userID}

                row := sdc.conn.QueryRowContext(ctx, stmt, args...)

                res := models.Resume{}

                err := row.Scan(&amp;res.ID, &amp;res.UserID, &amp;res.JobTitle, &amp;res.CreatedAt, &amp;res.UpdatedAt, &amp;res.Version)

                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                err = errors.New("could not find a resume")
                        }</span>
                        <span class="cov0" title="0">errorChan &lt;- err
                        return</span>
                }
                <span class="cov0" title="0">resumeChan &lt;- &amp;res</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return nil, err</span>
        case resume := &lt;-resumeChan:<span class="cov0" title="0">
                return resume, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, ctx.Err()
                }</span>
                <span class="cov0" title="0">return nil, errors.New("query timedout")</span>
        }

}
</pre>
		
		<pre class="file" id="file50" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetResumeContactDetails(resumeID int64) (*models.ContactDetail, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        contactDetailChan := make(chan *models.ContactDetail)
        errorChan := make(chan error)
        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(contactDetailChan)
                defer close(errorChan)

                stmt := `
                select 
                        resume_contact_details.id as res_cd_id, 
                        resume_contact_details.resume_id as res_cd_res_id,
                        resume_contact_details.first_name as res_cd_firstname,
                        resume_contact_details.last_name as res_cd_lastname,
                        resume_contact_details.address_1 as res_cd_address1,
                        resume_contact_details.address_2 as res_cd_address2,
                        resume_contact_details.city as res_cd_city,
                        resume_contact_details.state as res_cd_state,
                        resume_contact_details.zipcode as res_cd_zipcode,
                        resume_contact_details.email as res_cd_email,
                        resume_contact_details.phone_number as res_cd_phone,
                        resume_contact_details.web_address as res_cd_web_address,
                        resume_contact_details.created_at as res_cd_created_at,
                        resume_contact_details.updated_at as res_cd_updated_at,
                        resume_contact_details.version as res_cd_version
                        from resume_contact_details
                WHERE resume_contact_details.resume_id = ?
                ORDER BY 
                        resume_contact_details.created_at ASC;
                `

                args := []any{resumeID}

                cd := models.ContactDetail{}

                err := sdc.conn.QueryRowContext(ctx, stmt, args...).Scan(
                        &amp;cd.ID,
                        &amp;cd.ResumeID,
                        &amp;cd.Firstname,
                        &amp;cd.Lastname,
                        &amp;cd.AddressLine1,
                        &amp;cd.AddressLine2,
                        &amp;cd.City,
                        &amp;cd.State,
                        &amp;cd.Zipcode,
                        &amp;cd.Email,
                        &amp;cd.PhoneNumber,
                        &amp;cd.WebAddress,
                        &amp;cd.CreatedAt,
                        &amp;cd.UpdatedAt,
                        &amp;cd.Version)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">contactDetailChan &lt;- &amp;cd</span>

        }()

        <span class="cov0" title="0">return &lt;-contactDetailChan, &lt;-errorChan</span>

}
</pre>
		
		<pre class="file" id="file51" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetResumeObjective(resumeID int64) (*models.Objective, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        objectiveChan := make(chan *models.Objective)
        errorChan := make(chan error)
        sdc.app.WG.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer close(objectiveChan)
                defer close(errorChan)
                defer sdc.app.WG.Done()

                stmt := `
                select
                        objectives.id as res_obj_id,
                        objectives.resume_id as res_res_id,
                        objectives.content as res_content,
                        objectives.created_at as res_created_at,
                        objectives.updated_at as res_updated_at,
                        objectives.version as res_obj_version
                        FROM objectives
                        WHERE resume_id = ?
                        ORDER BY created_AT ASC
                `

                args := []any{resumeID}

                row := sdc.conn.QueryRowContext(ctx, stmt, args...)

                obj := models.Objective{}

                err := row.Scan(&amp;obj.ID, &amp;obj.ResumeID, &amp;obj.Content, &amp;obj.CreatedAt, &amp;obj.UpdatedAt, &amp;obj.Version)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">objectiveChan &lt;- &amp;obj</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return nil, err</span>
        case objective := &lt;-objectiveChan:<span class="cov0" title="0">
                return objective, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

// GetSkillItems accepts a resumeID of type int64 and returns *models.SkillList or an error
// it performs a join query to get all unique skills that belong to a group
// using the resumeID to return the skill list items that belong to that resume
func (sdc *SQLDbConn) GetSkillItems(resumeID int64) (*models.SkillList, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        skillListChan := make(chan *models.SkillList)
        errChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(skillListChan)
                defer close(errChan)

                stmt := `
                select
        skill_lists.id,
        skill_lists.resume_id,
        skill_lists.title,
        skill_lists.created_at,
        skill_lists.updated_at,
        skill_lists.version,
        skill_list_items.id,
        skill_list_items.skill_lists_id,
        skill_list_items.title,
        skill_list_items.content,
        skill_list_items.duration,
        skill_list_items.created_at,
        skill_list_items.updated_at,
        skill_list_items.version
        FROM skill_lists
        INNER JOIN skill_list_items ON skill_list_items.skill_lists_id = skill_lists.id
        WHERE skill_lists.resume_id = ?
        ORDER BY skill_list_items.created_at asc;
                `

                args := []any{resumeID}

                rows, err := sdc.conn.QueryContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">skList := models.SkillList{}

                defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{
                        skItem := models.SkillListItem{}

                        err := rows.Scan(
                                &amp;skList.ID,
                                &amp;skList.ResumeID,
                                &amp;skList.Title,
                                &amp;skList.CreatedAt,
                                &amp;skList.UpdatedAt,
                                &amp;skList.Version,
                                &amp;skItem.ID,
                                &amp;skItem.SKillListID,
                                &amp;skItem.Title,
                                &amp;skItem.Content,
                                &amp;skItem.Duration,
                                &amp;skItem.CreatedAt,
                                &amp;skItem.UpdatedAt,
                                &amp;skItem.Version,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">skList.Items = append(skList.Items, &amp;skItem)</span>

                }

                <span class="cov0" title="0">skillListChan &lt;- &amp;skList</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case skillList := &lt;-skillListChan:<span class="cov0" title="0">
                return skillList, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

}
</pre>
		
		<pre class="file" id="file53" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) GetResumeSocialMedia(resumeID int64) (*models.SocialMediaList, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        sdc.app.WG.Add(1)
        errorChan := make(chan error)
        smListChan := make(chan *models.SocialMediaList)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(errorChan)
                defer close(smListChan)

                stmt := `
        select
                social_media_lists.id as sml_id,
                social_media_lists.resume_id as sml_resume_id,
                social_media_lists.created_at as sml_created_at,
                social_media_lists.updated_at as sml_updated_at,
                social_media_lists.version as sml_version,
                social_media_list_items.id as sml_item_id,
                social_media_list_items.social_media_lists_id as sml_item_list_id,
                social_media_list_items.company_name as sml_item_company_name,
                social_media_list_items.username as sml_item_username,
                social_media_list_items.web_address as sml_item_web_address,
                social_media_list_items.created_at as sml_item_created_at,
                social_media_list_items.updated_at as sml_item_updated_at,
                social_media_list_items.version as sml_item_version
        from social_media_lists
        left join social_media_list_items ON
                social_media_list_items.social_media_lists_id = social_media_lists.id
        WHERE
                social_media_lists.resume_id = ?;
                `

                args := []any{resumeID}

                rows, err := sdc.conn.QueryContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">defer rows.Close()

                smList := models.SocialMediaList{}

                for rows.Next() </span><span class="cov0" title="0">{

                        listItem := models.SocialMediaListItems{}

                        err := rows.Scan(
                                &amp;smList.ID,
                                &amp;smList.ResumeID,
                                &amp;smList.CreatedAt,
                                &amp;smList.UpdatedAt,
                                &amp;smList.Version,
                                &amp;listItem.ID,
                                &amp;listItem.SocialMediaListID,
                                &amp;listItem.CompanyName,
                                &amp;listItem.UserName,
                                &amp;listItem.WebAddress,
                                &amp;listItem.CreatedAt,
                                &amp;listItem.UpdatedAt,
                                &amp;listItem.Version,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">smList.SocialMediaListItems = append(smList.SocialMediaListItems, &amp;listItem)</span>

                }

                <span class="cov0" title="0">smListChan &lt;- &amp;smList</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return nil, err</span>
        case smList := &lt;-smListChan:<span class="cov0" title="0">
                return smList, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) InsertCategory(cat *models.Category) (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        idChan := make(chan int64)
        errChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(idChan)
                defer close(errChan)

                stmt := `INSERT INTO categories (name,created_at,updated_at,version) VALUES(?,?,?,?)`

                args := []any{cat.Name, cat.CreatedAt, cat.UpdatedAt, cat.Version}

                result, err := sdc.conn.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">id, err := result.LastInsertId()

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">idChan &lt;- id</span>

        }()

        <span class="cov0" title="0">select </span>{
        case id := &lt;-idChan:<span class="cov0" title="0">
                return id, nil</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return 0, err</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) InsertCategoryPostJoin(catJoin *models.CategoryPostJoin) (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        idChan := make(chan int64)
        errChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(idChan)
                defer close(errChan)

                stmt := `INSERT INTO category_joins (cat_id,post_id) VALUES(?,?)`

                args := []any{catJoin.CatID, catJoin.PostID}

                result, err := sdc.conn.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">id, err := result.LastInsertId()

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">idChan &lt;- id</span>
        }()

        <span class="cov0" title="0">select </span>{
        case id := &lt;-idChan:<span class="cov0" title="0">
                return id, nil</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return 0, err</span>
        }

}
</pre>
		
		<pre class="file" id="file56" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) InsertMessage(msg *models.ContactMsg) (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        idChan := make(chan int64)
        errChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(idChan)
                defer close(errChan)

                stmt := `
                INSERT INTO messages (email, message,created_at,version) VALUES(?,?,?,?);
                `

                args := []any{msg.Email, msg.Message, msg.CreatedAt, msg.Version}

                result, err := sdc.conn.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">id, err := result.LastInsertId()

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">idChan &lt;- id</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return 0, err</span>
        case id := &lt;-idChan:<span class="cov0" title="0">
                return id, nil</span>
        }

}
</pre>
		
		<pre class="file" id="file57" style="display: none">package sqldbconn

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) InsertResume(rme *models.Resume) (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*30)

        defer cancel()

        idChan := make(chan int64)
        errorChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(idChan)
                defer close(errorChan)

                tx, err := sdc.conn.BeginTx(ctx, nil)

                if err != nil </span><span class="cov0" title="0">{
                        err = tx.Rollback()
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">stmt := `
                INSERT INTO
                resumes
                (
                        user_id,
                        job_title,
                        created_at,
                        updated_at,
                        version
                ) VALUES(
                ?,?,?,?,?        
                )
                `

                args := []any{rme.UserID, rme.JobTitle, rme.CreatedAt, rme.UpdatedAt, rme.Version}

                result, err := tx.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("resumes")
                        errorChan &lt;- err
                        err = tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">resumeID, err := result.LastInsertId()

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("resumes id")
                        errorChan &lt;- err
                        err = tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // objective

                <span class="cov0" title="0">stmt = `
                INSERT INTO
                        objectives
                        (
                                resume_id,
                        content
                )
                        VALUES(?,?);
                `

                args = []any{resumeID, rme.Objective.Content}

                _, err = tx.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        err = tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // contact details

                <span class="cov0" title="0">stmt = `
                insert into
                        resume_contact_details
                        (
                                resume_id,
                                first_name,
                                last_name,
                                address_1,
                                address_2,
                                city,
                                state,
                                zipcode,
                                email, 
                                phone_number,
                                web_address
                        )
                        VALUES(?,?,?,?,?,?,?,?,?,?,?)
                `

                cd := rme.ContactDetail

                contactDetailsArgs := []any{
                        resumeID,
                        cd.Firstname,
                        cd.Lastname,
                        cd.AddressLine1,
                        cd.AddressLine2,
                        cd.City,
                        cd.State,
                        cd.Zipcode,
                        cd.Email,
                        cd.PhoneNumber,
                        cd.WebAddress,
                }

                result, err = tx.ExecContext(ctx, stmt, contactDetailsArgs...)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        err = tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">contactDetailID, err := result.LastInsertId()
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        err = tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">rme.ContactDetail.ID = contactDetailID

                //        skill list group

                if len(rme.SkillList.Items) &gt; 0 </span><span class="cov0" title="0">{

                        stmt = `
                insert into
                skill_lists
                (resume_id)
                values(?)
                `

                        args = []any{resumeID}

                        result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">skillListGroupID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">rme.SkillList.ID = skillListGroupID

                        // Skill List Items

                        for i := range rme.SkillList.Items </span><span class="cov0" title="0">{
                                rme.SkillList.Items[i].SKillListID = skillListGroupID
                        }</span>

                        <span class="cov0" title="0">stmt = `
                insert into
                skill_list_items
                (
                        skill_lists_id,
                        title,
                        content,
                        duration
                )
                values
                `

                        // build multi row insert

                        skillListItemRows := buildMultiRowInsert(len(rme.SkillList.Items), 4)

                        stmt += skillListItemRows

                        // build args

                        args = []any{}

                        for i := range rme.SkillList.Items </span><span class="cov0" title="0">{
                                var item = rme.SkillList.Items[i]
                                args = append(args, skillListGroupID, item.Title, item.Content, item.Duration)
                        }</span>

                        <span class="cov0" title="0">result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">lastSkillListItemID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">for i := range rme.SkillList.Items </span><span class="cov0" title="0">{
                                rme.SkillList.Items[i].ID = lastSkillListItemID
                        }</span>
                }

                // Employment History Group

                <span class="cov0" title="0">if len(rme.EmploymentList.Employers) &gt; 0 </span><span class="cov0" title="0">{

                        stmt = `
                insert into
                employment_lists
                (
                        resume_id
                )
                values (?)
                `

                        args = []any{resumeID}

                        result, err = tx.ExecContext(ctx, stmt, args...)

                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">employmentListID, err := result.LastInsertId()

                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">rme.EmploymentList.ID = employmentListID

                        // Employment History Items

                        stmt = `
                insert into
                        employment_list_items
                        (
                                employment_lists_id,
                                title,
                                date_from,
                                date_to,
                                job_title,
                                summary
                        )
                        values
                `

                        stmt += buildMultiRowInsert(len(rme.EmploymentList.Employers), 6)

                        args = []any{}

                        for i := range rme.EmploymentList.Employers </span><span class="cov0" title="0">{
                                rme.EmploymentList.Employers[i].EmploymentListID = employmentListID
                                var item = rme.EmploymentList.Employers[i]
                                args = append(args, item.EmploymentListID, item.Title, item.From, item.To, item.JobTitle, item.Summary)
                        }</span>

                        <span class="cov0" title="0">result, err = tx.ExecContext(ctx, stmt, args...)

                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }

                // Social Media Group

                <span class="cov0" title="0">if len(rme.SocialMediaList.SocialMediaListItems) &gt; 0 </span><span class="cov0" title="0">{

                        stmt = `
                insert into
                        social_media_lists
                        (resume_id)
                        values (?)
                `

                        args = []any{resumeID}

                        result, err = tx.ExecContext(ctx, stmt, args...)

                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">socialMediaListID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">rme.SocialMediaList.ID = socialMediaListID

                        for i := range rme.SocialMediaList.SocialMediaListItems </span><span class="cov0" title="0">{
                                rme.SocialMediaList.SocialMediaListItems[i].SocialMediaListID = socialMediaListID
                        }</span>

                        // Social Media Items

                        <span class="cov0" title="0">stmt = `
                insert into
                        social_media_list_items
                        (
                                social_media_lists_id,
                                company_name,
                                username,
                                web_address
                        )
                        values
                `

                        smItems := rme.SocialMediaList.SocialMediaListItems

                        stmt += buildMultiRowInsert(len(smItems), 4)

                        args = []any{}

                        for i := 0; i &lt; len(rme.SocialMediaList.SocialMediaListItems); i++ </span><span class="cov0" title="0">{
                                var item = rme.SocialMediaList.SocialMediaListItems[i]
                                args = append(args, item.SocialMediaListID, item.CompanyName, item.UserName, item.WebAddress)
                        }</span>

                        <span class="cov0" title="0">result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">lastSMItemID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">for i := range rme.SocialMediaList.SocialMediaListItems </span><span class="cov0" title="0">{
                                rme.SocialMediaList.SocialMediaListItems[i].ID = lastSMItemID
                        }</span>
                }

                // Education List Group

                <span class="cov0" title="0">if len(rme.EducationList.Education) &gt; 0 </span><span class="cov0" title="0">{

                        stmt = `
                insert into
                        education_lists
                        (
                                resume_id
                        )
                        values (?)
                `

                        args = []any{}

                        args = append(args, resumeID)

                        result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">educationListID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">rme.EducationList.ID = educationListID

                        // Education List Items

                        stmt = `
                insert into
                        education_items
                        (
                                education_lists_id,
                                name,
                                degree_year,
                                degree,
                                address_1,
                                address_2,
                                city,
                                state,
                                zipcode
                        )
                        values 
                `

                        stmt += buildMultiRowInsert(len(rme.EducationList.Education), 9)

                        args = []any{}

                        for i := range rme.EducationList.Education </span><span class="cov0" title="0">{
                                rme.EducationList.Education[i].EducationListID = educationListID
                                item := rme.EducationList.Education[i]
                                args = append(args, item.EducationListID, item.Name, item.DegreeYear, item.Degree, item.Address1, item.Address2, item.City, item.State, item.Zipcode)
                        }</span>

                        <span class="cov0" title="0">result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }

                // Award List Group

                <span class="cov0" title="0">if len(rme.AwardsList.Awards) &gt; 0 </span><span class="cov0" title="0">{

                        stmt = `
                insert into
                        award_lists
                        (resume_id)
                        values (?)
                `

                        args = []any{}
                        args = append(args, resumeID)

                        result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">awardListID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        // Award List Items

                        <span class="cov0" title="0">stmt = `
                insert into
                        award_items
                        (
                                award_list_id,
                                title,
                                org_name,
                                received_year,
                                content
                        )
                        values 
                `

                        stmt += buildMultiRowInsert(len(rme.AwardsList.Awards), 5)

                        args = []any{}

                        for i := range rme.AwardsList.Awards </span><span class="cov0" title="0">{
                                rme.AwardsList.Awards[i].AwardListID = awardListID
                                item := rme.AwardsList.Awards[i]

                                args = append(args, item.AwardListID, item.Title, item.OrganizationName, item.Year, item.Content)
                        }</span>

                        <span class="cov0" title="0">result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }

                // Reference List Group
                <span class="cov0" title="0">if len(rme.ReferenceList.ReferenceList) &gt; 0 </span><span class="cov0" title="0">{
                        stmt = `
                insert into
                        reference_lists
                        (resume_id)
                        values (?)
                `
                        args = []any{resumeID}

                        result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">referenceListID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">rme.ReferenceList.ID = referenceListID

                        for i := range rme.ReferenceList.ReferenceList </span><span class="cov0" title="0">{
                                rme.ReferenceList.ReferenceList[i].ReferenceListID = referenceListID
                        }</span>

                        // Reference List Items

                        <span class="cov0" title="0">stmt = `
                insert into
                        reference_items
                        (
                                ref_list_id,
                                first_name,
                                last_name,
                                email,
                                phone_number,
                                job_title,
                                organization,
                                type,
                                address_1,
                                address_2,
                                city,
                                state,
                                zipcode,
                                content
                        )
                        values  
                `
                        stmt += buildMultiRowInsert(len(rme.ReferenceList.ReferenceList), 14)

                        args = []any{}

                        for i := range rme.ReferenceList.ReferenceList </span><span class="cov0" title="0">{
                                item := rme.ReferenceList.ReferenceList[i]
                                rme.ReferenceList.ReferenceList[i].ReferenceListID = referenceListID
                                args = append(args,
                                        item.ReferenceListID,
                                        item.FirstName,
                                        item.LastName,
                                        item.Email,
                                        item.PhoneNumber,
                                        item.JobTitle,
                                        item.Organization,
                                        item.Type,
                                        item.Address1,
                                        item.Address2,
                                        item.City,
                                        item.State,
                                        item.Zipcode,
                                        item.Content)
                        }</span>

                        <span class="cov0" title="0">result, err = tx.ExecContext(ctx, stmt, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- err
                                err = tx.Rollback()
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- err
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }

                // commit
                <span class="cov0" title="0">err = tx.Commit()
                if err != nil </span><span class="cov0" title="0">{
                        err = tx.Rollback()
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">idChan &lt;- resumeID</span>

        }()

        <span class="cov0" title="0">select </span>{
        case id := &lt;-idChan:<span class="cov0" title="0">
                rme.ID = id
                updateResumeID(rme, id)
                return id, nil</span>
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return 0, err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return 0, ctx.Err()</span>
        }
}

func updateResumeID(resume *models.Resume, resumeID int64) <span class="cov0" title="0">{
        resume.Objective.ResumeID = resumeID
        resume.ContactDetail.ResumeID = resumeID
        resume.SkillList.ResumeID = resumeID
        resume.EmploymentList.ResumeID = resumeID
        resume.SocialMediaList.ResumeID = resumeID
        resume.EducationList.ResumeID = resumeID
        resume.AwardsList.ResumeID = resumeID
        resume.ReferenceList.ResumeID = resumeID
}</span>

// buildMultiRowInsert creates an empty slice with the capacity of
// numValsPerRow and returns the joined string for db inserts
// append after VALUES in insert statement
// this is used to build prepared statements
func buildMultiRowInsert(numRows, numValsPerRow int) string <span class="cov0" title="0">{
        if numRows &lt; 1 || numValsPerRow &lt; 1 </span><span class="cov0" title="0">{
                return "()"
        }</span>

        <span class="cov0" title="0">var out []string

        for i := 0; i &lt; numRows; i++ </span><span class="cov0" title="0">{
                s := make([]string, numValsPerRow) // null val slice with length zero but capacity of numValsPerRow
                for j := 0; j &lt; numValsPerRow; j++ </span><span class="cov0" title="0">{
                        s[j] = "?"
                }</span>
                <span class="cov0" title="0">var v = strings.Join(s, ", ")
                out = append(out, fmt.Sprintf("(%s)", v))</span>
        }

        <span class="cov0" title="0">return strings.Join(out, ",")</span>

}
</pre>
		
		<pre class="file" id="file58" style="display: none">package sqldbconn

import (
        "context"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

func (sdc *SQLDbConn) ListCategories() ([]*models.Category, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        catChan := make(chan *models.Category)
        errChan := make(chan error)
        doneChan := make(chan bool)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(catChan)
                defer close(errChan)
                defer close(doneChan)

                stmt := `SELECT id, name, created_at, updated_at, version FROM categories`

                rows, err := sdc.conn.QueryContext(ctx, stmt)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        doneChan &lt;- true
                        return
                }</span>

                <span class="cov0" title="0">defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{
                        cat := models.Category{}
                        err := rows.Scan(&amp;cat.ID, &amp;cat.Name, &amp;cat.CreatedAt, &amp;cat.UpdatedAt, &amp;cat.Version)

                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                doneChan &lt;- true
                                return
                        }</span>

                        <span class="cov0" title="0">catChan &lt;- &amp;cat</span>
                }

                <span class="cov0" title="0">if rows.Err() != nil </span><span class="cov0" title="0">{
                        errChan &lt;- rows.Err()
                        doneChan &lt;- true
                        return
                }</span>

                <span class="cov0" title="0">doneChan &lt;- true</span>

        }()

        <span class="cov0" title="0">cats := []*models.Category{}
        var err error

        for </span><span class="cov0" title="0">{
                select </span>{
                case cat := &lt;-catChan:<span class="cov0" title="0">
                        cats = append(cats, cat)</span>
                case e := &lt;-errChan:<span class="cov0" title="0">
                        err = e</span>
                case &lt;-doneChan:<span class="cov0" title="0">
                        return cats, err</span>
                }
        }

}
</pre>
		
		<pre class="file" id="file59" style="display: none">package sqldbconn

import (
        "context"
        "crypto/sha256"
        "database/sql"
        "errors"
        "fmt"
        "html"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/config"
        "github.com/elkcityhazard/andrew-mccall-go/internal/models"
)

type SQLDbConn struct {
        app  *config.AppConfig
        conn *sql.DB
}

func NewSQLDbConn(app *config.AppConfig, conn *sql.DB) *SQLDbConn <span class="cov0" title="0">{
        return &amp;SQLDbConn{
                app:  app,
                conn: conn,
        }
}</span>
func (sdc *SQLDbConn) ActivateUser(u *models.User) (int64, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        idChan := make(chan int64)
        errChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(idChan)
                defer close(errChan)

                tx, err := sdc.conn.BeginTx(ctx, &amp;sql.TxOptions{})

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">stmt := `
                UPDATE users 
                SET users.is_active = ?,
                users.updated_at = ?,
                users.version = users.version + 1
                WHERE users.id = ?
                AND users.version = ?
                `

                args := []any{1, time.Now(), u.ID, u.Version}

                result, err := tx.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">id, err := result.LastInsertId()

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

                // delete token
                <span class="cov0" title="0">delStmt := `
        DELETE FROM activation_tokens
        WHERE activation_tokens.user_id = ?
        `

                delResult, err := tx.ExecContext(ctx, delStmt, u.ID)

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">affected, err := delResult.RowsAffected()

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- errors.New("an error has occurred")
                        return
                }</span>

                <span class="cov0" title="0">err = tx.Commit()

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">idChan &lt;- id</span>

        }()

        <span class="cov0" title="0">select </span>{
        case id := &lt;-idChan:<span class="cov0" title="0">
                return id, nil</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return 0, err</span>
        }

}
func (sdc *SQLDbConn) GetActivationToken(tokenString string) (*models.User, *models.ActivationToken, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        tokenHash := sha256.Sum256([]byte(tokenString))
        userChan := make(chan *models.User)
        tokenChan := make(chan *models.ActivationToken)
        errChan := make(chan error)
        doneChan := make(chan bool)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()

                stmt := `
                select
                users.id,
                users.email,
                users.username,
                users.password,
                users.created_at,
                users.updated_at,
                users.is_active,
                users.role,
                users.version,
                passwords.id,
                passwords.hash,
                passwords.created_at,
                passwords.updated_at,
                passwords.is_active,
                passwords.version,
                activation_tokens.id,
                activation_tokens.hash,
                activation_tokens.user_id,
                activation_tokens.expiry,
                activation_tokens.scope
                FROM users
                INNER JOIN
                activation_tokens ON
                users.id = activation_tokens.user_id
                INNER JOIN passwords ON
                users.password = passwords.id
                WHERE activation_tokens.hash = ?
                AND activation_tokens.expiry &gt; ?
                AND passwords.is_active = 0
                `

                pw := models.Password{}
                u := models.User{}
                u.Password = &amp;pw
                at := models.ActivationToken{}

                args := []any{tokenHash[:], time.Now()}

                err := sdc.conn.QueryRowContext(ctx, stmt, args...).Scan(
                        &amp;u.ID,
                        &amp;u.Email,
                        &amp;u.Username,
                        &amp;u.Password.ID,
                        &amp;u.CreatedAt,
                        &amp;u.UpdatedAt,
                        &amp;u.IsActive,
                        &amp;u.Role,
                        &amp;u.Version,
                        &amp;pw.ID,
                        &amp;pw.Hash,
                        &amp;pw.CreatedAt,
                        &amp;pw.UpdatedAt,
                        &amp;pw.IsActive,
                        &amp;pw.Version,
                        &amp;at.ID,
                        &amp;at.Hash,
                        &amp;at.UserID,
                        &amp;at.Expiry,
                        &amp;at.Scope,
                )

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        doneChan &lt;- true
                        return
                }</span>

                <span class="cov0" title="0">at.Plaintext = tokenString

                u.Password = &amp;pw

                userChan &lt;- &amp;u

                tokenChan &lt;- &amp;at

                doneChan &lt;- true</span>

        }()

        <span class="cov0" title="0">var u *models.User
        var t *models.ActivationToken
        var e error

        for </span><span class="cov0" title="0">{
                select </span>{
                case usr := &lt;-userChan:<span class="cov0" title="0">
                        u = usr</span>
                case acTok := &lt;-tokenChan:<span class="cov0" title="0">
                        t = acTok</span>
                case err := &lt;-errChan:<span class="cov0" title="0">
                        e = err
                        return u, t, e</span>
                case &lt;-doneChan:<span class="cov0" title="0">
                        close(tokenChan)
                        close(userChan)
                        close(errChan)
                        close(doneChan)
                        return u, t, e</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        e = ctx.Err()
                        return u, t, e</span>
                }
        }

}
func (sdc *SQLDbConn) InsertActivationToken(at *models.ActivationToken) (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        tokenChan := make(chan *models.ActivationToken)
        errorChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer close(tokenChan)
                defer close(errorChan)

                defer sdc.app.WG.Done()

                stmt := `

                INSERT INTO activation_tokens 
                (hash, user_id, expiry,scope)
                VALUES(?,?,?,?)
                `

                args := []any{at.Hash, at.UserID, at.Expiry, at.Scope}

                result, err := sdc.conn.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">id, err := result.LastInsertId()

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">at.ID = id

                tokenChan &lt;- at</span>

        }()

        <span class="cov0" title="0">select </span>{
        case token := &lt;-tokenChan:<span class="cov0" title="0">
                return token.ID, nil</span>
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return 0, err</span>
        }

}
func (sdc *SQLDbConn) GetNextPrevPost(post *models.Content, increment bool) (*models.Content, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        postChan := make(chan *models.Content)
        errorChan := make(chan error)
        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(postChan)
                defer close(errorChan)

                var stmt string

                if !increment </span><span class="cov0" title="0">{
                        stmt = `
                SELECT 
                        posts.id, 
                        posts.title,
                        posts.slug 
                        FROM posts 
                        WHERE posts.created_at &lt; ? AND posts.status = "published"
                        ORDER BY posts.created_at
                        DESC
                        LIMIT 1;
                `
                }</span> else<span class="cov0" title="0"> {

                        stmt = `
                SELECT 
                        posts.id, 
                        posts.title, 
                        posts.slug 
                        FROM posts 
                        WHERE posts.created_at &gt; ?  AND posts.status = "published"
                        ORDER BY posts.created_at
                        ASC
                        LIMIT 1;
                `
                }</span>

                <span class="cov0" title="0">var p models.Content

                err := sdc.conn.QueryRowContext(ctx, stmt, post.CreatedAt).Scan(&amp;p.ID, &amp;p.Title, &amp;p.Slug)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">postChan &lt;- &amp;p</span>

        }()

        <span class="cov0" title="0">select </span>{
        case post := &lt;-postChan:<span class="cov0" title="0">
                return post, nil</span>
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return nil, err</span>
        }

}
func (sdc *SQLDbConn) GetUserByID(id int64) (*models.User, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        userChan := make(chan *models.User)
        errChan := make(chan error)
        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer close(userChan)
                defer close(errChan)
                defer sdc.app.WG.Done()

                stmt := `
                SELECT id,email,username FROM users WHERE id = ?
                `
                user := models.User{}

                err := sdc.conn.QueryRowContext(ctx, stmt, id).Scan(&amp;user.ID, &amp;user.Email, &amp;user.Username)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">userChan &lt;- &amp;user</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case user := &lt;-userChan:<span class="cov0" title="0">
                return user, nil</span>
        }
}
func (sdc *SQLDbConn) ListPosts(limit, offset int) ([]*models.Content, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        postChan := make(chan *models.Content)
        errChan := make(chan error)
        doneChan := make(chan bool)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()

                stmt := `
                SELECT 
                        posts.id,
                        posts.user_id,
                        posts.title,
                        posts.slug,
                        posts.description,
                        posts.content,
                        posts.delta,
                        posts.created_at,
                        posts.updated_at,
                        posts.status,
                        posts.version,
                        users.email
                FROM posts
                INNER JOIN
                users
                On posts.user_id = users.id
                WHERE
                        posts.created_at &lt;= CURRENT_TIMESTAMP
                AND posts.status = ?
                ORDER BY posts.created_at DESC
                LIMIT ?
                OFFSET ?
                `

                args := []any{"published", limit, offset}

                rows, err := sdc.conn.QueryContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{
                        var c models.Content

                        var email string

                        err := rows.Scan(
                                &amp;c.ID,
                                &amp;c.UserId,
                                &amp;c.Title,
                                &amp;c.Slug,
                                &amp;c.Description,
                                &amp;c.Content,
                                &amp;c.Delta,
                                &amp;c.CreatedAt,
                                &amp;c.UpdatedAt,
                                &amp;c.Status,

                                &amp;c.Version,
                                &amp;email)
                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">postChan &lt;- &amp;c</span>
                }

                <span class="cov0" title="0">doneChan &lt;- true</span>

        }()

        <span class="cov0" title="0">var posts []*models.Content

        for </span><span class="cov0" title="0">{
                select </span>{
                case post := &lt;-postChan:<span class="cov0" title="0">
                        posts = append(posts, post)</span>
                case err := &lt;-errChan:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                close(postChan)
                                close(errChan)
                                close(doneChan)
                                return nil, err
                        }</span>
                case &lt;-doneChan:<span class="cov0" title="0">
                        close(postChan)
                        close(errChan)
                        close(doneChan)
                        return posts, nil</span>

                }
        }

}

func (sdc *SQLDbConn) GetPaginatedPosts(userID int64, offset, size int) ([]*models.Content, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        postChan := make(chan *models.Content)
        errChan := make(chan error)
        doneChan := make(chan bool)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()

                stmt := `
                SELECT id,title,slug,description,created_at,updated_at,status,version
                FROM posts
                WHERE user_id = ? 
                LIMIT ? 
                OFFSET ?
                `

                args := []any{userID, size, offset}

                rows, err := sdc.conn.QueryContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        doneChan &lt;- true
                        return
                }</span>

                <span class="cov0" title="0">defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{

                        var c = models.Content{}

                        err := rows.Scan(&amp;c.ID, &amp;c.Title, &amp;c.Slug, &amp;c.Description, &amp;c.CreatedAt, &amp;c.UpdatedAt, &amp;c.Status, &amp;c.Version)

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                errChan &lt;- err
                                doneChan &lt;- true
                        }</span>
                        <span class="cov0" title="0">postChan &lt;- &amp;c</span>
                }
                <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- errors.New("no rows")
                }</span>
                <span class="cov0" title="0">doneChan &lt;- true</span>

        }()

        <span class="cov0" title="0">var posts = []*models.Content{}

        var err error

        for </span><span class="cov0" title="0">{
                select </span>{
                case post := &lt;-postChan:<span class="cov0" title="0">
                        posts = append(posts, post)</span>

                case errOp := &lt;-errChan:<span class="cov0" title="0">
                        err = errOp</span>

                case &lt;-doneChan:<span class="cov0" title="0">
                        close(postChan)
                        close(errChan)
                        close(doneChan)

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return posts, nil</span>
                }
        }

}
func (sdc *SQLDbConn) UpdatePost(c *models.Content) (int64, error) <span class="cov0" title="0">{ //        returns version
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)
        defer cancel()

        affectedChan := make(chan int64)
        errorChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer close(affectedChan)
                defer close(errorChan)
                defer sdc.app.WG.Done()

                stmt := `UPDATE posts
                SET
                title = ?,
                slug = ?,
                description = ?,
                content = ?,
                delta = ?,
                updated_at = ?,
                version = version + 1,
                status = ?
                WHERE id = ? AND version = ?`

                args := []any{c.Title, c.Slug, c.Description, c.Content, c.Delta, c.UpdatedAt, c.Status, c.ID, c.Version}

                tx, err := sdc.conn.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelDefault})

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">result, err := tx.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback()
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">affected, err := result.RowsAffected()

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">if affected &gt; 0 </span><span class="cov0" title="0">{

                        affectedChan &lt;- affected

                }</span>
        }()
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case affected := &lt;-affectedChan:<span class="cov0" title="0">
                        return affected, nil</span>
                case err := &lt;-errorChan:<span class="cov0" title="0">
                        return 0, err</span>
                }
        }

}
func (sdc *SQLDbConn) GetBlogPostByID(id int64) (*models.Content, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        postChan := make(chan *models.Content)
        errorChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(postChan)
                defer close(errorChan)

                stmt := `SELECT id,user_id,title,slug,description,content,delta,created_at,updated_at,status,version FROM posts WHERE id = ?`

                post := models.Content{}

                err := sdc.conn.QueryRowContext(ctx, stmt, id).Scan(&amp;post.ID, &amp;post.UserId, &amp;post.Title, &amp;post.Slug, &amp;post.Description, &amp;post.Content, &amp;post.Delta, &amp;post.CreatedAt, &amp;post.UpdatedAt, &amp;post.Status, &amp;post.Version)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">postChan &lt;- &amp;post</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return nil, err</span>
        case post := &lt;-postChan:<span class="cov0" title="0">
                return post, nil</span>
        }
}
func (sdc *SQLDbConn) GetBlogPost(routekey string) (*models.Content, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        postChan := make(chan *models.Content)
        errorChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(postChan)
                defer close(errorChan)

                stmt := `SELECT id,user_id,title,slug,description,content,created_at,updated_at,status,version FROM posts WHERE slug = ?`

                post := models.Content{}

                err := sdc.conn.QueryRowContext(ctx, stmt, routekey).Scan(&amp;post.ID, &amp;post.UserId, &amp;post.Title, &amp;post.Slug, &amp;post.Description, &amp;post.Content, &amp;post.CreatedAt, &amp;post.UpdatedAt, &amp;post.Status, &amp;post.Version)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">postChan &lt;- &amp;post</span>

        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return nil, err</span>
        case post := &lt;-postChan:<span class="cov0" title="0">
                return post, nil</span>
        }
}

func (sdc *SQLDbConn) InsertEditorContent(c *models.Content) (int64, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        idChan := make(chan int64)
        errorChan := make(chan error)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(idChan)
                defer close(errorChan)

                stmt := `INSERT INTO 
                posts 
                (
                        user_id,
                        title,
                        slug,
                        description,
                        content,
                        delta,
                        created_at,
                        updated_at,
                        status,
                        version
                ) 
                VALUES(?,?,?,?,?,?,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP,?,1)`

                args := []any{c.UserId, c.Title, c.Slug, c.Description, c.Content, c.Delta, c.Status}

                tx, err := sdc.conn.BeginTx(ctx, nil)

                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return
                }</span>

                <span class="cov0" title="0">result, err := tx.ExecContext(ctx, stmt, args...)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                        return
                }</span>

                <span class="cov0" title="0">insertedID, err := result.LastInsertId()

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                        return
                }</span>

                <span class="cov0" title="0">err = tx.Commit()

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                        return
                }</span>

                <span class="cov0" title="0">c.ID = insertedID

                idChan &lt;- insertedID</span>
        }()

        <span class="cov0" title="0">select </span>{
        case insertedID := &lt;-idChan:<span class="cov0" title="0">
                return insertedID, nil</span>
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return 0, err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return 0, ctx.Err()</span>
        }

}

func (sdc *SQLDbConn) GetUserByEmail(email string) (*models.User, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        userChan := make(chan *models.User, 1)
        errorChan := make(chan error, 1)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(userChan)
                defer close(errorChan)

                stmt := `
                select 
                users.id,
                users.email,
                users.username,
                users.created_at,
                users.updated_at,
                users.is_active,
                users.role,
                users.version,
                passwords.id,
                passwords.hash
                FROM users
                inner join 
                passwords on
                users.password = passwords.id
                WHERE users.email = ?
                `

                u := &amp;models.User{}
                p := &amp;models.Password{}
                err := sdc.conn.QueryRowContext(ctx, stmt, email).Scan(&amp;u.ID, &amp;u.Email, &amp;u.Username, &amp;u.CreatedAt, &amp;u.UpdatedAt, &amp;u.IsActive, &amp;u.Role, &amp;u.Version, &amp;p.ID, &amp;p.Hash)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">u.Password = p

                userChan &lt;- u</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case user := &lt;-userChan:<span class="cov0" title="0">
                        return user, nil</span>
                case err := &lt;-errorChan:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }

}

func (sdc *SQLDbConn) InsertUser(u *models.User) (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*10)

        defer cancel()

        idChan := make(chan int64, 1)
        errorChan := make(chan error, 1)

        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer sdc.app.WG.Done()
                defer close(idChan)
                defer close(errorChan)
                tx, err := sdc.conn.BeginTx(ctx, nil)
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                        return
                }</span>
                <span class="cov0" title="0">pwStmt := `INSERT INTO passwords (hash) VALUES(?)`
                pwResult, err := tx.ExecContext(ctx, pwStmt, u.Password.Hash)
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                        return
                }</span>

                <span class="cov0" title="0">pwID, err := pwResult.LastInsertId()
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                        return
                }</span>

                <span class="cov0" title="0">u.Password.ID = pwID

                usrStmt := `INSERT INTO users (email,username,password,role, is_active) VALUES(?,?,?,?,?)`

                usrArgs := []interface{}{u.Email, u.Username, u.Password.ID, u.Role, u.IsActive}

                usrResult, err := tx.ExecContext(ctx, usrStmt, usrArgs...)

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                        return
                }</span>

                <span class="cov0" title="0">usrID, err := usrResult.LastInsertId()
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                        return
                }</span>

                <span class="cov0" title="0">u.ID = usrID

                idChan &lt;- u.ID

                err = tx.Commit()

                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        tx.Rollback()
                }</span>

        }()

        <span class="cov0" title="0">return &lt;-idChan, &lt;-errorChan</span>

}

func (sdc *SQLDbConn) GetTotalCount(table string) (int, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(sdc.app.Context, time.Second*15)

        defer cancel()

        countChan := make(chan int, 1)
        errChan := make(chan error, 1)
        sdc.app.WG.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer close(countChan)
                defer close(errChan)
                defer sdc.app.WG.Done()

                var count int

                stmt := fmt.Sprintf("SELECT COUNT(id) FROM %s", html.EscapeString(table))

                err := sdc.conn.QueryRowContext(ctx, stmt).Scan(&amp;count)

                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">countChan &lt;- count</span>

        }()

        <span class="cov0" title="0">select </span>{
        case count := &lt;-countChan:<span class="cov0" title="0">
                return count, nil</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return 0, err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return 0, ctx.Err()</span>
        }

}
</pre>
		
		<pre class="file" id="file60" style="display: none">package static

import "embed"

//go:embed css
//go:embed dist
var static embed.FS

func GetStaticDir() embed.FS <span class="cov0" title="0">{
        return static
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package templates

import (
        "embed"
        "fmt"
        "html"
        "html/template"
        "log"
        "strings"
        "time"

        "github.com/elkcityhazard/andrew-mccall-go/internal/repository/sqldbconn"
)

//go:embed templates
var templateDir embed.FS

var (
        templatePageDir    = "templates/pages"
        templateLayoutDir  = "templates/layouts"
        templatePartialDir = "templates/partials"
)

// templateRepo is a ne wsqldbconn to fetch the user and utilize any other dbservicers
var templateRepo *sqldbconn.SQLDbConn

func SetTemplateSQLDbRepo(sq *sqldbconn.SQLDbConn) <span class="cov0" title="0">{
        templateRepo = sq
}</span>

var tFuncs = template.FuncMap{
        "parseEditorContent": parseQuillContent,
        "unsafeHTML":         unsafeHTML,
        "humanDate":          humanDate,
        "fetchUser":          fetchUser,
        "calculateLimit":     calculateLimit,
        "calculateOffset":    calculateOffset,
        "toLower":            strings.ToLower,
        "getCategoryName":    getCategoryName,
        "formatPluralYear":   formatPluralYear,
}

func formatPluralYear(year int) string <span class="cov0" title="0">{
        if year == 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d year", year)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d years", year)</span>
}

func getCategoryName(id int64) string <span class="cov0" title="0">{
        cat, err := templateRepo.GetCategoryByPostID(id)

        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return cat.Name</span>
}

func calculateLimit(limit, offset, count int, increment bool) int <span class="cov0" title="0">{
        switch true </span>{
        case limit &lt; 0:<span class="cov0" title="0">
                return 10</span>
        case limit &gt;= count:<span class="cov0" title="0">
                return 10</span>
        default:<span class="cov0" title="0">
                return limit</span>
        }
}

func calculateOffset(limit, offset, count int, increment bool) int <span class="cov0" title="0">{

        var off int

        if increment </span><span class="cov0" title="0">{
                if offset+limit &gt;= count </span><span class="cov0" title="0">{
                        off = offset
                }</span> else<span class="cov0" title="0"> if offset+limit &lt; 0 </span><span class="cov0" title="0">{
                        off = 0
                }</span> else<span class="cov0" title="0"> {
                        off = offset + limit
                }</span>
        }

        <span class="cov0" title="0">if !increment </span><span class="cov0" title="0">{
                if offset-limit &lt; 0 </span><span class="cov0" title="0">{
                        off = 0
                }</span> else<span class="cov0" title="0"> if offset-limit &gt;= count </span><span class="cov0" title="0">{
                        off = offset
                }</span> else<span class="cov0" title="0"> {
                        off = offset - limit
                }</span>
        }

        <span class="cov0" title="0">return off</span>
}

func fetchUser(id int64) string <span class="cov0" title="0">{

        user, err := templateRepo.GetUserByID(id)

        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return user.Username</span>
}
func humanDate(datetime time.Time) string <span class="cov0" title="0">{
        return datetime.Format("Jan 02, 2006")
}</span>

func unsafeHTML(content string) string <span class="cov0" title="0">{
        return html.EscapeString(content)
}</span>

func parseQuillContent(content string) template.HTML <span class="cov0" title="0">{

        return template.HTML(content)

}</span>

func GetTemplateDir() *embed.FS <span class="cov0" title="0">{
        return &amp;templateDir
}</span>

func BuildTemplateCache() map[string]*template.Template <span class="cov0" title="0">{

        var tc = make(map[string]*template.Template)

        pages, err := templateDir.ReadDir(templatePageDir)

        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err)
        }</span>

        <span class="cov0" title="0">for _, page := range pages </span><span class="cov0" title="0">{
                tmpl, err := template.New(page.Name()).Funcs(tFuncs).ParseFS(templateDir, fmt.Sprintf("%s/%s", templatePageDir, page.Name()))

                if err != nil </span><span class="cov0" title="0">{
                        log.Panic(err)
                }</span>

                <span class="cov0" title="0">layouts, err := templateDir.ReadDir(templateLayoutDir)

                if err != nil </span><span class="cov0" title="0">{
                        log.Panic(err)
                }</span>

                <span class="cov0" title="0">if len(layouts) &gt; 0 </span><span class="cov0" title="0">{
                        for _, l := range layouts </span><span class="cov0" title="0">{
                                tmpl, err = tmpl.ParseFS(templateDir, fmt.Sprintf("%s/%s", templateLayoutDir, l.Name()))

                                if err != nil </span><span class="cov0" title="0">{
                                        log.Panic(err)
                                }</span>
                        }
                }

                <span class="cov0" title="0">partials, err := templateDir.ReadDir(templatePartialDir)

                if err != nil </span><span class="cov0" title="0">{
                        log.Panic(err)
                }</span>

                <span class="cov0" title="0">if len(partials) &gt; 0 </span><span class="cov0" title="0">{
                        for _, p := range partials </span><span class="cov0" title="0">{
                                tmpl, err = tmpl.ParseFS(templateDir, fmt.Sprintf("%s/%s", templatePartialDir, p.Name()))

                                if err != nil </span><span class="cov0" title="0">{
                                        log.Panic(err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">tc[page.Name()] = tmpl</span>
        }
        <span class="cov0" title="0">return tc</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package utils

import (
        "fmt"
        "regexp"
        "strings"
        "time"
)

// Slugify takes in a string and attempts to convert it to a slug
// it trims spaces from the end, sets to all lowecase,
// and attemps to replace special characters, duplicate spaces, and duplicates dashes
// it also attempts to ensure that there are no trailing or leading dashes
func (u *Util) Slugify(slug string) string <span class="cov8" title="1">{

        if strings.HasPrefix(slug, "/") </span><span class="cov0" title="0">{
                slug = slug[1:]
        }</span>

        <span class="cov8" title="1">slug = strings.TrimSpace(slug)
        slug = strings.ToLower(slug)

        spaceRe := regexp.MustCompile(`\s+`)

        slug = spaceRe.ReplaceAllString(slug, " ")

        specialRe := regexp.MustCompile(`[^a-zA-Z0-9-\/]`)
        slug = specialRe.ReplaceAllString(slug, "-")

        dashRe := regexp.MustCompile(`\W+`)
        slug = dashRe.ReplaceAllString(slug, "-")

        if strings.HasSuffix(slug, "-") </span><span class="cov8" title="1">{
                slug = slug[:len(slug)-1]
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(slug, "-") </span><span class="cov8" title="1">{
                slug = slug[1:]
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s/%s", u.GenerateDateSlug(), slug)</span>
}

func (u *Util) GenerateDateSlug() string <span class="cov8" title="1">{
        var dateEls []any

        dateEls = append(dateEls, time.Now().Year(), int(time.Now().Month()), time.Now().Day())
        return fmt.Sprintf("/%04d/%02d/%02d", dateEls...)

}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package utils

import (
        "image"
        "image/jpeg"
        "image/png"
        "io"
        "math"
        "regexp"

        "golang.org/x/image/draw"
)

type Util struct {
}

// NewUtil returns a new utility instance and exposes the methods
func NewUtil() *Util <span class="cov8" title="1">{
        return &amp;Util{}
}</span>

// CreateJSONEnvelope assigns a key to a new map and fills it with data
func (u *Util) CreateJSONEnvelope(key string, data any) map[string]any <span class="cov8" title="1">{
        if len(key) &lt; 1 </span><span class="cov8" title="1">{
                key = "data"
        }</span>

        <span class="cov8" title="1">if data == nil </span><span class="cov8" title="1">{
                data = make(map[string]any)
        }</span>
        <span class="cov8" title="1">var envelope = make(map[string]any)

        envelope[key] = data

        return envelope</span>
}

func (u *Util) ResizeImage(rdr io.Reader, wtr io.Writer, mimetype string, width int) (err error) <span class="cov0" title="0">{
        var src image.Image

        switch mimetype </span>{
        case "image/jpeg":<span class="cov0" title="0">
                src, err = jpeg.Decode(rdr)</span>
        case "image/png":<span class="cov0" title="0">
                src, err = png.Decode(rdr)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ratio := (float64)(src.Bounds().Max.Y) / (float64)(src.Bounds().Max.X)
        height := int(math.Round(float64(width) * ratio))

        dst := image.NewRGBA(image.Rect(0, 0, width, height))

        draw.CatmullRom.Scale(dst, dst.Rect, src, src.Bounds(), draw.Over, nil)
        err = jpeg.Encode(wtr, dst, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

// CheckPWStrength does some exremely basic pass word strenth checks and returns a bool if it passes or not
func (u *Util) CheckPWStrength(pw string, minLength int) bool <span class="cov8" title="1">{

        if len(pw) &lt; minLength </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">charRe, err := regexp.Compile("[^a-zA-Z0-9\\n]")

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">hasSpecialChar := charRe.MatchString(pw)

        if !hasSpecialChar </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">alphaRe, err := regexp.Compile("[a-zA-Z]")

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">hasAlpha := alphaRe.MatchString(pw)

        if !hasAlpha </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">numRe, err := regexp.Compile("[0-9]")

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">hasNum := numRe.MatchString(pw)

        if !hasNum </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>

}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
